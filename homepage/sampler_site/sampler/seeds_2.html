<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sampler: seeds_2</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="../index.html#top">최상위 문서</a><a class="btn" href="../index.html#integrated-model">통합 관점</a><a class="btn" href="../index.html#bridge">KSampler 브리지</a><a class="btn" href="../symbol/index.html">기호 위키</a><a class="btn" href="../index.html#sampler-catalog">Sampler Catalog</a></div><h1>Sampler: <code>seeds_2</code></h1><div class="chips"><span class="chip">family: SEEDS</span><span class="chip">stochastic: yes</span><span class="chip">cfg_pp: no</span><span class="chip">gpu_variant: no</span><span class="chip">standalone: no</span></div><p><strong>ComfyUI 함수 시그니처</strong><br><code>sample_seeds_2(model, x, sigmas, extra_args=None, callback=None, disable=None, eta=1., s_noise=1., noise_sampler=None, r=0.5, solver_type="phi_1")</code></p><p class='small'><strong>docstring:</strong> SEEDS-2 - Stochastic Explicit Exponential Derivative-free Solvers (VP Data Prediction) stage 2.
arXiv: https://arxiv.org/abs/2305.14267 (NeurIPS 2023)</p><div class='formula'>$$ x_{k+1}=\Phi_{\mathrm{special\ SDE}}(\text{stage/order})+\Phi_{\mathrm{noise}} $$</div><p>SDE 특화 계열. drift 항보다 stochastic design(eta/s_noise/tau_func/noise_scaler)이 출력 분산과 질감에 큰 영향을 준다.</p><p>FPE 관점에서 drift + diffusion가 모두 활성화된다: $\partial_t\rho=-\nabla\cdot(\rho b)+\frac12 g^2\Delta\rho$. OT 관점에서는 entropic regularization이 있는 bridge 해석이 자연스럽다.</p><h2>수학 심화 프로파일</h2><h3>순수수학 관점</h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>method class</td><td>stochastic PC/SDE 특화</td></tr><tr><td>local truncation</td><td>$$ O(h^{p+1})\ \text{(drift)} + O(h^{q+1/2})\ \text{(diffusion)} $$</td></tr><tr><td>global error</td><td>$$ weak error 중심으로 해석하는 것이 실용적 $$</td></tr><tr><td>strong/weak 관점</td><td>noise 설계(eta, s_noise, tau_func, noise_scaler)가 지배적</td></tr><tr><td>stability 메모</td><td>확산항 스케일이 과하면 질감은 증가하지만 구조 안정성은 저하</td></tr></tbody></table><div class='formula'>$$\mathcal{L}_t\varphi=b_t\cdot\nabla\varphi+\frac12 g_t^2\Delta\varphi,\quad \partial_t\rho_t=\mathcal{L}_t^\star\rho_t$$</div><div class='formula'>$$\rho_{k+1}\approx\arg\min_\rho\left(\frac{W_2^2(\rho,\rho_k)}{2\tau_k}+\mathcal{F}(\rho)\right)$$</div><div class='formula'>$$\|x(t_{k+1})-x_{k+1}\|\le C h_k^{p+1},\quad \|x(T)-x_N\|\le C\max_k h_k^p,\quad h_k:=|\lambda_{k+1}-\lambda_k|$$</div><h3>수치해석/구현 관점</h3><table><thead><tr><th>구현 항목</th><th>내용</th></tr></thead><tbody><tr><td>스텝 커널 구조</td><td>$$x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</td></tr><tr><td>모델 평가량(경향)</td><td>구현/분기 조건에 따라 변동.</td></tr><tr><td>history 버퍼</td><td>명시적 history 버퍼 의존이 낮은 단일스텝 구조.</td></tr><tr><td>스텝 제어</td><td>고정 mesh 위에서 noise injection 파라미터(eta, s_noise 등)로 분산 제어.</td></tr><tr><td>메쉬 변수</td><td>$$\lambda=\log\alpha-\log\sigma,\ h_k=|\lambda_{k+1}-\lambda_k|$$</td></tr><tr><td>저장/정밀도 메모</td><td>기본 latent + 중간 stage 텐서 저장 비용이 주된 메모리 사용처.</td></tr></tbody></table><div class='formula'>$$\lambda=\log\alpha-\log\sigma,\quad x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</div><div class='formula'>$$v_{\mathrm{cfg}}=v_u+w(v_c-v_u)$$</div><div class='formula'>$$x_{k+1}=m_k(x_k)+G_k\xi_k,\ \xi_k\sim\mathcal{N}(0,I),\ \mathrm{Cov}[x_{k+1}|x_k]=G_kG_k^\top$$</div><p class='small'><strong>family:</strong> SEEDS / <strong>stochastic:</strong> yes</p><h2>유도 스케치(순수수학) / 구현 절차(수치해석)</h2><p class='small'><strong>대상:</strong> <code>seeds_2</code> / <strong>family:</strong> SEEDS</p><h3>순수수학 유도 스케치</h3><div class='formula'>$$\sigma_m=\sigma_k^{1-r}\sigma_{k+1}^{r},\quad x_m=\Phi(x_k,\sigma_k\to\sigma_m),\quad x_{k+1}=\Phi(x_m,\sigma_m\to\sigma_{k+1})+\Gamma_k\xi_k$$</div><p class='small'>주요 오차원천: 중간 stage 비율 $$r$$ 선택, solver_type 보정 선택, 노이즈 주입 분산.</p><h3>수치해석 구현 절차</h3><ol class='list'><li>중간 sigma를 생성해 2-stage 적분을 수행한다.</li><li><code>r</code>과 <code>solver_type</code>이 품질/안정성 균형을 좌우한다.</li><li><code>eta</code>, <code>s_noise</code>는 다양성-구조 보존 균형 파라미터다.</li></ol><p class='path'><strong>ComfyUI 경로:</strong> <code>comfy/k_diffusion/sampling.py::sample_seeds_2</code></p><p class='path'><strong>독립 구현 전략:</strong> 현재는 comfy_native 위임 권장(후속 standalone 확장)</p><h2>기호 계약(정의역/공역/조건)</h2><p class='small'>기호별 상세 위키: <a class='row-link' href='../symbol/index.html'><strong>Symbol Wiki Index</strong></a></p><div class='topnav'><a class="btn" href="../symbol/X.html">$\mathcal{X}$</a><a class="btn" href="../symbol/Sigma.html">$\Sigma$</a><a class="btn" href="../symbol/D_theta.html">$D_\theta$</a><a class="btn" href="../symbol/Phi_k.html">$\Phi_k$</a><a class="btn" href="../symbol/Psi_k.html">$\Psi_k$</a><a class="btn" href="../symbol/S_map.html">$S$</a><a class="btn" href="../symbol/Xi_k.html">$\xi_k$</a><a class="btn" href="../symbol/Fk.html">$\mathcal{F}_k$</a><a class="btn" href="../symbol/Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><table><thead><tr><th>항목</th><th>수식</th><th>설명</th></tr></thead><tbody><tr><td>상태 변수</td><td>$x_k:(\Omega,\mathcal{F}_k)\to(\mathcal{X},\mathcal{B}(\mathcal{X}))$</td><td>$\mathcal{X}$는 보통 $\mathbb{R}^d$ (유한차원 힐베르트 공간).</td></tr><tr><td>조건 변수</td><td>$c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})$ 또는 고정 매개변수 $c\in\mathcal{C}$</td><td>조건은 가측 사상 또는 상수 매개변수로 모델링.</td></tr><tr><td>스케줄 사상</td><td>$S:\{0,\dots,N\}\to\Sigma$, $k\mapsto\sigma_k$</td><td>단조감소 가정이 일반적이며 $h_k=|\lambda_{k+1}-\lambda_k|$가 오차를 지배.</td></tr><tr><td>모형 사상</td><td>$D_\theta:(\mathcal{X}\times\Sigma\times\mathcal{C})\to\mathcal{X}$</td><td>측도론적으로는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{B}(\Sigma)\otimes\mathcal{G},\mathcal{B}(\mathcal{X}))$-가측 사상.</td></tr><tr><td>이산시간 전이 사상</td><td>$\Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X}$</td><td>시간지수 $k$에서 $k+1$로 가는 상태전이 사상.</td></tr><tr><td>다단계 과거값 갱신 사상</td><td>$\Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1}$</td><td>과거값 벡터를 다음 단계의 과거값 벡터로 옮기는 사상.</td></tr><tr><td>적응성/가측성</td><td>$x_k$는 $\mathcal{F}_k$-가측, $\Phi_k$는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{A}_k\otimes\mathcal{F}_k,\mathcal{B}(\mathcal{X}))$-가측</td><td>미래 잡음 미참조(non-anticipative) 조건을 형식화.</td></tr><tr><td>기저 확률공간</td><td>$\Omega=(\mathbb{R}^d)^N$, $\mathcal{F}=\mathcal{B}(\Omega)$, $\mathbb{P}=\bigotimes_{k=0}^{N-1}\mathcal{N}(0,I_d)$</td><td>이산 stochastic sampler의 표준 곱측도 모델.</td></tr><tr><td>잡음 확률변수</td><td>$\xi_k:(\Omega,\mathcal{F},\mathbb{P})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))$, $\xi_k\sim\mathcal{N}(0,I_d)$</td><td>$\xi_k\in L^2(\Omega;\mathbb{R}^d)$. 상관잡음이면 공분산 연산자를 명시해야 함.</td></tr><tr><td>필트레이션</td><td>$\mathcal{F}_k=\sigma(\xi_0,\dots,\xi_{k-1})$ 및 $x_k$의 $\mathcal{F}_k$-가측성</td><td>현재 상태가 과거 정보에만 의존한다는 적응성 조건.</td></tr><tr><td>접두 경로공간</td><td>$\Omega_k=(\mathbb{R}^d)^k$</td><td>k-step까지 사용한 난수 경로를 나타내는 부분공간.</td></tr></tbody></table><p class='small'>해석 팁: <code>k</code>는 이산 step index, <code>t</code>는 연속시간 변수로 구분한다. 또한 $\mathcal{X}\times\mathcal{H}_k\times\Omega_k$ 위에서 정의된 $\Phi_k$의 가측성은 코드에서 난수 소비 순서(시드 재현성)와 직접 연결된다.</p><h3>직관/구체 원소 예시</h3><table><thead><tr><th>기호</th><th>원소 예시</th><th>직관</th></tr></thead><tbody><tr><td>$x_k\in\mathcal{X}$</td><td>$d=4$ 예시에서 $x_k=(0.12,-0.34,1.08,0.00)$</td><td>현재 latent 상태의 한 점.</td></tr><tr><td>$h_k\in\mathcal{H}_k$</td><td>2-step이면 $h_k=(x_{k-1},x_k)$</td><td>다단계 solver의 과거값 벡터.</td></tr><tr><td>$\Phi_k$</td><td>$x_{k+1}=\Phi_k(x_k,h_k,\omega_k)$</td><td>한 step에서 상태를 다음 상태로 보내는 사상.</td></tr><tr><td>$\Psi_k$</td><td>$\Psi_k((x_{k-1},x_k),x_{k+1})=(x_k,x_{k+1})$</td><td>슬라이딩 윈도우 형태의 과거값 갱신.</td></tr><tr><td>$\omega\in\Omega$</td><td>$\omega=(\xi_0,\xi_1,\dots,\xi_{N-1})$</td><td>전체 샘플링 과정에서 소비될 난수 경로 하나.</td></tr><tr><td>$\xi_k$</td><td>$d=3$ 예시: $\xi_k=(0.31,-1.24,0.08)$</td><td>k번째 step의 가우시안 잡음 벡터.</td></tr></tbody></table><h3>해당 sampler의 추가 제약</h3><table><thead><tr><th>제약</th><th>조건</th><th>의미</th></tr></thead><tbody><tr><td>mesh 단조성</td><td>$\sigma_{k+1}\le\sigma_k$, $h_k:=|\lambda_{k+1}-\lambda_k|>0$</td><td>역적분 안정성 및 오차 분석의 기본 가정.</td></tr><tr><td>drift 정칙성</td><td>$\|b_\theta(x,t)-b_\theta(y,t)\|\le L\|x-y\|$</td><td>존재/유일성과 수치해석 수렴률에 필요한 대표 가정.</td></tr><tr><td>확률강도</td><td>$\eta\ge0$</td><td>noise 주입 강도/드리프트 감쇠 결합.</td></tr><tr><td>노이즈 배율</td><td>$s_{noise}\ge0$</td><td>분산 스케일 파라미터.</td></tr><tr><td>중간 stage 비율</td><td>$0<r<1$</td><td>2-stage 보간 위치.</td></tr><tr><td>보정자 선택</td><td>$solver\_type\in\{\mathrm{midpoint},\mathrm{heun}\}$</td><td>보정식 계열 전환.</td></tr></tbody></table><h2>공통 인자(시그니처 공통부)</h2><table><thead><tr><th>인자</th><th>타입/의미</th><th>역할</th></tr></thead><tbody><tr><td><code>model</code></td><td>denoiser callable</td><td>모델 함수</td></tr><tr><td><code>x</code></td><td>latent</td><td>현재 상태</td></tr><tr><td><code>sigmas</code></td><td>sigma schedule</td><td>스텝별 노이즈 스케일</td></tr><tr><td><code>extra_args</code></td><td>dict</td><td>seed/model_options 등 추가 인자</td></tr><tr><td><code>callback</code></td><td>callable</td><td>진행 콜백</td></tr><tr><td><code>disable</code></td><td>bool</td><td>progress disable</td></tr></tbody></table><h2>sampler 고유 파라미터 상세</h2><table><thead><tr><th>파라미터</th><th>기본값</th><th>수학/알고리즘 역할</th><th>KSampler 노출 경로</th></tr></thead><tbody><tr><td><code>eta</code></td><td><code>1.</code></td><td>확률항 강도 및 drift 감쇠에 반영</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>s_noise</code></td><td><code>1.</code></td><td>noise term 배수</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>noise_sampler</code></td><td><code>None</code></td><td>코드 레벨 노이즈 샘플러 함수 주입</td><td>코드 레벨 파라미터.</td></tr><tr><td><code>r</code></td><td><code>0.5</code></td><td>중간 stage 비율</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>solver_type</code></td><td><code>"phi_1"</code></td><td>보정 방식(midpoint/heun 등) 선택</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr></tbody></table><h2>파라미터-수식 기호 대응</h2><table><thead><tr><th>코드 파라미터</th><th>수식 기호</th><th>들어가는 항</th><th>해석</th></tr></thead><tbody><tr><td><code>model</code></td><td>$$ \hat{x}_0(\cdot;\theta,c) $$</td><td>drift 항</td><td>denoiser/score 기반 추정기</td></tr><tr><td><code>x</code></td><td>$$ x_k $$</td><td>상태 변수</td><td>현재 latent 상태</td></tr><tr><td><code>sigmas</code></td><td>$$ \{\sigma_k\}_{k=0}^{N} $$</td><td>시간 재매개화</td><td>노이즈 스케줄 격자</td></tr><tr><td><code>extra_args</code></td><td>$$ c,\ \text{options} $$</td><td>조건 벡터장</td><td>conditioning/옵션 전달</td></tr><tr><td><code>callback</code></td><td>$$ \mathcal{C}_k $$</td><td>관측 함수</td><td>수치 궤적 모니터링</td></tr><tr><td><code>disable</code></td><td>$$ - $$</td><td>UI/로그 제어</td><td>수학 항에는 직접 미참여</td></tr><tr><td><code>eta</code></td><td>$$ \eta $$</td><td>diffusion 강도</td><td>노이즈 주입 강도 및 drift 감쇠와 결합</td></tr><tr><td><code>s_noise</code></td><td>$$ s_{\text{noise}} $$</td><td>noise 스케일</td><td>\xi_k \mapsto s_{\text{noise}}\xi_k</td></tr><tr><td><code>noise_sampler</code></td><td>$$ noise_sampler $$</td><td>구현 의존</td><td>sampler-specific tuning parameter</td></tr><tr><td><code>r</code></td><td>$$ r\in(0,1) $$</td><td>중간 stage 위치</td><td>2-stage 비율</td></tr><tr><td><code>solver_type</code></td><td>$$ \psi\in\{\text{midpoint, heun}\} $$</td><td>보정 연산자</td><td>corrector 식 선택</td></tr></tbody></table><h2>원본 구현 스니펫</h2><div class='codebox'>def sample_seeds_2(model, x, sigmas, extra_args=None, callback=None, disable=None, eta=1., s_noise=1., noise_sampler=None, r=0.5, solver_type="phi_1"):
    """SEEDS-2 - Stochastic Explicit Exponential Derivative-free Solvers (VP Data Prediction) stage 2.
    arXiv: https://arxiv.org/abs/2305.14267 (NeurIPS 2023)
    """
    if solver_type not in {"phi_1", "phi_2"}:
        raise ValueError("solver_type must be 'phi_1' or 'phi_2'")

    extra_args = {} if extra_args is None else extra_args
    seed = extra_args.get("seed", None)
    noise_sampler = default_noise_sampler(x, seed=seed) if noise_sampler is None else noise_sampler
    s_in = x.new_ones([x.shape[0]])
    inject_noise = eta &gt; 0 and s_noise &gt; 0

    model_sampling = model.inner_model.model_patcher.get_model_object('model_sampling')
    sigma_fn = partial(half_log_snr_to_sigma, model_sampling=model_sampling)
    lambda_fn = partial(sigma_to_half_log_snr, model_sampling=model_sampling)</div><div class="topnav"><a class="btn" href="er_sde.html">이전: er_sde</a><a class="btn" href="seeds_3.html">다음: seeds_3</a></div></article></div></body></html>