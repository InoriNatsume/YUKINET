<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sampler: dpm_2</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="../index.html#top">최상위 문서</a><a class="btn" href="../index.html#integrated-model">통합 관점</a><a class="btn" href="../index.html#bridge">KSampler 브리지</a><a class="btn" href="../symbol/index.html">기호 위키</a><a class="btn" href="../index.html#sampler-catalog">Sampler Catalog</a></div><h1>Sampler: <code>dpm_2</code></h1><div class="chips"><span class="chip">family: DPM</span><span class="chip">stochastic: no</span><span class="chip">cfg_pp: no</span><span class="chip">gpu_variant: no</span><span class="chip">standalone: no</span></div><p><strong>ComfyUI 함수 시그니처</strong><br><code>sample_dpm_2(model, x, sigmas, extra_args=None, callback=None, disable=None, s_churn=0., s_tmin=0., s_tmax=float('inf'), s_noise=1.)</code></p><p class='small'><strong>docstring:</strong> A sampler inspired by DPM-Solver-2 and Algorithm 2 from Karras et al. (2022).</p><div class='formula'>$$ \sigma_{\mathrm{mid}}=\exp((\log\sigma_k+\log\sigma_{k+1})/2),\ x_{k+1}\approx x_k+d(\sigma_{\mathrm{mid}})\Delta\sigma (+ noise) $$</div><p>2차 보정이 들어가는 계열로, 동일 step에서 Euler보다 drift 근사 bias가 작다. 다만 SDE 변형은 noise 항 영향으로 분산 trade-off가 발생한다.</p><p>결정론 경로로 보면 확산항이 제거된 continuity equation 관점: $\partial_t\rho+\nabla\cdot(\rho v)=0$. 동적 OT(Benamou-Brenier) 형태의 수송 해석이 용이하다.</p><h2>수학 심화 프로파일</h2><h3>순수수학 관점</h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>method class</td><td>2차 predictor-corrector</td></tr><tr><td>local truncation</td><td>$$ O(h^3) $$</td></tr><tr><td>global error</td><td>$$ O(h^2) $$</td></tr><tr><td>strong/weak 관점</td><td>확률항이 있으면 강한 차수는 낮아질 수 있으나 평균 drift 근사 정확도는 우수</td></tr><tr><td>stability 메모</td><td>Euler 대비 drift 오차가 작고, 중간 stage 평가 덕분에 곡률 변화에 상대적으로 강함</td></tr></tbody></table><div class='formula'>$$\mathcal{L}_t\varphi=v_t\cdot\nabla\varphi,\quad \partial_t\rho_t+\nabla\cdot(\rho_t v_t)=0$$</div><div class='formula'>$$\min_{\rho,v}\int_0^1\!\!\int \frac12\|v_t(x)\|^2\rho_t(x)\,dx\,dt,\quad \partial_t\rho+\nabla\cdot(\rho v)=0$$</div><div class='formula'>$$\|x(t_{k+1})-x_{k+1}\|\le C h_k^{p+1},\quad \|x(T)-x_N\|\le C\max_k h_k^p,\quad h_k:=|\lambda_{k+1}-\lambda_k|$$</div><h3>수치해석/구현 관점</h3><table><thead><tr><th>구현 항목</th><th>내용</th></tr></thead><tbody><tr><td>스텝 커널 구조</td><td>$$x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</td></tr><tr><td>모델 평가량(경향)</td><td>대체로 step당 모델 평가 2회(예측+보정).</td></tr><tr><td>history 버퍼</td><td>명시적 history 버퍼 의존이 낮은 단일스텝 구조.</td></tr><tr><td>스텝 제어</td><td>고정 mesh의 deterministic stepper 제어.</td></tr><tr><td>메쉬 변수</td><td>$$\lambda=\log\alpha-\log\sigma,\ h_k=|\lambda_{k+1}-\lambda_k|$$</td></tr><tr><td>저장/정밀도 메모</td><td>기본 latent + 중간 stage 텐서 저장 비용이 주된 메모리 사용처.</td></tr></tbody></table><div class='formula'>$$\lambda=\log\alpha-\log\sigma,\quad x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</div><div class='formula'>$$v_{\mathrm{cfg}}=v_u+w(v_c-v_u)$$</div><div class='formula'>$$x_{k+1}=m_k(x_k),\quad \partial_t\rho+\nabla\cdot(\rho v)=0$$</div><p class='small'><strong>family:</strong> DPM / <strong>stochastic:</strong> no</p><h2>유도 스케치(순수수학) / 구현 절차(수치해석)</h2><p class='small'><strong>대상:</strong> <code>dpm_2</code> / <strong>family:</strong> DPM</p><h3>순수수학 유도 스케치</h3><div class='formula'>$$x_{k+1}=x_k+\mathcal{I}_k^{(drift)}+\mathcal{C}_k^{(history)}+\mathcal{N}_k^{(noise)}$$</div><p class='small'>이 항 분해에서 drift/correction/noise를 어떤 차수로 근사하는지가 sampler family의 본질이다.</p><h3>수치해석 구현 절차</h3><ol class='list'><li>scheduler로 mesh를 고정한 뒤 stepper를 선택한다.</li><li>history 버퍼와 모델 평가 횟수의 비용-정확도 균형을 맞춘다.</li><li>필요 시 stochastic 항을 조절해 분산과 구조 보존을 트레이드오프한다.</li></ol><p class='path'><strong>ComfyUI 경로:</strong> <code>comfy/k_diffusion/sampling.py::sample_dpm_2</code></p><p class='path'><strong>독립 구현 전략:</strong> 현재는 comfy_native 위임 권장(후속 standalone 확장)</p><h2>기호 계약(정의역/공역/조건)</h2><p class='small'>기호별 상세 위키: <a class='row-link' href='../symbol/index.html'><strong>Symbol Wiki Index</strong></a></p><div class='topnav'><a class="btn" href="../symbol/X.html">$\mathcal{X}$</a><a class="btn" href="../symbol/Sigma.html">$\Sigma$</a><a class="btn" href="../symbol/D_theta.html">$D_\theta$</a><a class="btn" href="../symbol/Phi_k.html">$\Phi_k$</a><a class="btn" href="../symbol/Psi_k.html">$\Psi_k$</a><a class="btn" href="../symbol/S_map.html">$S$</a><a class="btn" href="../symbol/Xi_k.html">$\xi_k$</a><a class="btn" href="../symbol/Fk.html">$\mathcal{F}_k$</a><a class="btn" href="../symbol/Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><table><thead><tr><th>항목</th><th>수식</th><th>설명</th></tr></thead><tbody><tr><td>상태 변수</td><td>$x_k:(\Omega,\mathcal{F}_k)\to(\mathcal{X},\mathcal{B}(\mathcal{X}))$</td><td>$\mathcal{X}$는 보통 $\mathbb{R}^d$ (유한차원 힐베르트 공간).</td></tr><tr><td>조건 변수</td><td>$c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})$ 또는 고정 매개변수 $c\in\mathcal{C}$</td><td>조건은 가측 사상 또는 상수 매개변수로 모델링.</td></tr><tr><td>스케줄 사상</td><td>$S:\{0,\dots,N\}\to\Sigma$, $k\mapsto\sigma_k$</td><td>단조감소 가정이 일반적이며 $h_k=|\lambda_{k+1}-\lambda_k|$가 오차를 지배.</td></tr><tr><td>모형 사상</td><td>$D_\theta:(\mathcal{X}\times\Sigma\times\mathcal{C})\to\mathcal{X}$</td><td>측도론적으로는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{B}(\Sigma)\otimes\mathcal{G},\mathcal{B}(\mathcal{X}))$-가측 사상.</td></tr><tr><td>이산시간 전이 사상</td><td>$\Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X}$</td><td>시간지수 $k$에서 $k+1$로 가는 상태전이 사상.</td></tr><tr><td>다단계 과거값 갱신 사상</td><td>$\Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1}$</td><td>과거값 벡터를 다음 단계의 과거값 벡터로 옮기는 사상.</td></tr><tr><td>적응성/가측성</td><td>$x_k$는 $\mathcal{F}_k$-가측, $\Phi_k$는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{A}_k\otimes\mathcal{F}_k,\mathcal{B}(\mathcal{X}))$-가측</td><td>미래 잡음 미참조(non-anticipative) 조건을 형식화.</td></tr><tr><td>결정론적 모델</td><td>$\Omega=\{\omega_0\}$, $\mathcal{F}=\{\varnothing,\Omega\}$, $\mathbb{P}(\Omega)=1$</td><td>확률기호는 형식적으로만 남고 난수항은 제거된다.</td></tr><tr><td>step 사상 축약</td><td>$\Phi_k:\mathcal{X}\times\mathcal{H}_k\to\mathcal{X}$</td><td>난수 인자 $\Omega_k$가 소거된 결정론적 사상으로 동작.</td></tr></tbody></table><p class='small'>해석 팁: <code>k</code>는 이산 step index, <code>t</code>는 연속시간 변수로 구분한다. 또한 $\mathcal{X}\times\mathcal{H}_k\times\Omega_k$ 위에서 정의된 $\Phi_k$의 가측성은 코드에서 난수 소비 순서(시드 재현성)와 직접 연결된다.</p><h3>직관/구체 원소 예시</h3><table><thead><tr><th>기호</th><th>원소 예시</th><th>직관</th></tr></thead><tbody><tr><td>$x_k\in\mathcal{X}$</td><td>$d=4$ 예시에서 $x_k=(0.12,-0.34,1.08,0.00)$</td><td>현재 latent 상태의 한 점.</td></tr><tr><td>$h_k\in\mathcal{H}_k$</td><td>2-step이면 $h_k=(x_{k-1},x_k)$</td><td>다단계 solver의 과거값 벡터.</td></tr><tr><td>$\Phi_k$</td><td>$x_{k+1}=\Phi_k(x_k,h_k,\omega_k)$</td><td>한 step에서 상태를 다음 상태로 보내는 사상.</td></tr><tr><td>$\Psi_k$</td><td>$\Psi_k((x_{k-1},x_k),x_{k+1})=(x_k,x_{k+1})$</td><td>슬라이딩 윈도우 형태의 과거값 갱신.</td></tr><tr><td>결정론적 경우</td><td>$\Omega=\{\omega_0\}$</td><td>난수 경로가 하나뿐이라 잡음항이 사라짐.</td></tr></tbody></table><h3>해당 sampler의 추가 제약</h3><table><thead><tr><th>제약</th><th>조건</th><th>의미</th></tr></thead><tbody><tr><td>mesh 단조성</td><td>$\sigma_{k+1}\le\sigma_k$, $h_k:=|\lambda_{k+1}-\lambda_k|>0$</td><td>역적분 안정성 및 오차 분석의 기본 가정.</td></tr><tr><td>drift 정칙성</td><td>$\|b_\theta(x,t)-b_\theta(y,t)\|\le L\|x-y\|$</td><td>존재/유일성과 수치해석 수렴률에 필요한 대표 가정.</td></tr><tr><td>노이즈 배율</td><td>$s_{noise}\ge0$</td><td>분산 스케일 파라미터.</td></tr></tbody></table><h2>공통 인자(시그니처 공통부)</h2><table><thead><tr><th>인자</th><th>타입/의미</th><th>역할</th></tr></thead><tbody><tr><td><code>model</code></td><td>denoiser callable</td><td>모델 함수</td></tr><tr><td><code>x</code></td><td>latent</td><td>현재 상태</td></tr><tr><td><code>sigmas</code></td><td>sigma schedule</td><td>스텝별 노이즈 스케일</td></tr><tr><td><code>extra_args</code></td><td>dict</td><td>seed/model_options 등 추가 인자</td></tr><tr><td><code>callback</code></td><td>callable</td><td>진행 콜백</td></tr><tr><td><code>disable</code></td><td>bool</td><td>progress disable</td></tr></tbody></table><h2>sampler 고유 파라미터 상세</h2><table><thead><tr><th>파라미터</th><th>기본값</th><th>수학/알고리즘 역할</th><th>KSampler 노출 경로</th></tr></thead><tbody><tr><td><code>s_churn</code></td><td><code>0.</code></td><td>일시적 sigma inflation 강도</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>s_tmin</code></td><td><code>0.</code></td><td>s_churn 적용 sigma 하한</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>s_tmax</code></td><td><code>float('inf')</code></td><td>s_churn 적용 sigma 상한</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>s_noise</code></td><td><code>1.</code></td><td>noise term 배수</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr></tbody></table><h2>파라미터-수식 기호 대응</h2><table><thead><tr><th>코드 파라미터</th><th>수식 기호</th><th>들어가는 항</th><th>해석</th></tr></thead><tbody><tr><td><code>model</code></td><td>$$ \hat{x}_0(\cdot;\theta,c) $$</td><td>drift 항</td><td>denoiser/score 기반 추정기</td></tr><tr><td><code>x</code></td><td>$$ x_k $$</td><td>상태 변수</td><td>현재 latent 상태</td></tr><tr><td><code>sigmas</code></td><td>$$ \{\sigma_k\}_{k=0}^{N} $$</td><td>시간 재매개화</td><td>노이즈 스케줄 격자</td></tr><tr><td><code>extra_args</code></td><td>$$ c,\ \text{options} $$</td><td>조건 벡터장</td><td>conditioning/옵션 전달</td></tr><tr><td><code>callback</code></td><td>$$ \mathcal{C}_k $$</td><td>관측 함수</td><td>수치 궤적 모니터링</td></tr><tr><td><code>disable</code></td><td>$$ - $$</td><td>UI/로그 제어</td><td>수학 항에는 직접 미참여</td></tr><tr><td><code>s_churn</code></td><td>$$ \gamma $$</td><td>sigma inflation</td><td>\hat{\sigma}=(1+\gamma)\sigma</td></tr><tr><td><code>s_tmin</code></td><td>$$ \sigma_{\text{low}} $$</td><td>churn 적용 구간</td><td>노이즈 주입 하한</td></tr><tr><td><code>s_tmax</code></td><td>$$ \sigma_{\text{high}} $$</td><td>churn 적용 구간</td><td>노이즈 주입 상한</td></tr><tr><td><code>s_noise</code></td><td>$$ s_{\text{noise}} $$</td><td>noise 스케일</td><td>\xi_k \mapsto s_{\text{noise}}\xi_k</td></tr></tbody></table><h2>원본 구현 스니펫</h2><div class='codebox'>def sample_dpm_2(model, x, sigmas, extra_args=None, callback=None, disable=None, s_churn=0., s_tmin=0., s_tmax=float('inf'), s_noise=1.):
    """A sampler inspired by DPM-Solver-2 and Algorithm 2 from Karras et al. (2022)."""
    extra_args = {} if extra_args is None else extra_args
    s_in = x.new_ones([x.shape[0]])
    for i in trange(len(sigmas) - 1, disable=disable):
        if s_churn &gt; 0:
            gamma = min(s_churn / (len(sigmas) - 1), 2 ** 0.5 - 1) if s_tmin &lt;= sigmas[i] &lt;= s_tmax else 0.
            sigma_hat = sigmas[i] * (gamma + 1)
        else:
            gamma = 0
            sigma_hat = sigmas[i]

        if gamma &gt; 0:
            eps = torch.randn_like(x) * s_noise
            x = x + eps * (sigma_hat ** 2 - sigmas[i] ** 2) ** 0.5
        denoised = model(x, sigma_hat * s_in, **extra_args)</div><div class="topnav"><a class="btn" href="exp_heun_2_x0_sde.html">이전: exp_heun_2_x0_sde</a><a class="btn" href="dpm_2_ancestral.html">다음: dpm_2_ancestral</a></div></article></div></body></html>