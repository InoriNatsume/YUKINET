<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sampler: euler_ancestral</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="../index.html#top">최상위 문서</a><a class="btn" href="../index.html#integrated-model">통합 관점</a><a class="btn" href="../index.html#bridge">KSampler 브리지</a><a class="btn" href="../symbol/index.html">기호 위키</a><a class="btn" href="../index.html#sampler-catalog">Sampler Catalog</a></div><h1>Sampler: <code>euler_ancestral</code></h1><div class="chips"><span class="chip">family: Euler</span><span class="chip">stochastic: yes</span><span class="chip">cfg_pp: no</span><span class="chip">gpu_variant: no</span><span class="chip">standalone: yes</span></div><p><strong>ComfyUI 함수 시그니처</strong><br><code>sample_euler_ancestral(model, x, sigmas, extra_args=None, callback=None, disable=None, eta=1., s_noise=1., noise_sampler=None)</code></p><div class='formula'>$$ x_{k+1}=x_k+d_k(\sigma_{\mathrm{down}}-\sigma_k)+s_{\mathrm{noise}}\sigma_{\mathrm{up}}\xi_k $$</div><p>Euler 계열은 1차 근사(국소 오차 O(h^2), 전역 O(h)) 해석이 기본이며, ancestral/SDE 변형은 통계적 분산 항이 추가된다.</p><p>FPE 관점에서 drift + diffusion가 모두 활성화된다: $\partial_t\rho=-\nabla\cdot(\rho b)+\frac12 g^2\Delta\rho$. OT 관점에서는 entropic regularization이 있는 bridge 해석이 자연스럽다.</p><h2>수학 심화 프로파일</h2><h3>순수수학 관점</h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>method class</td><td>단일 스텝 Euler/EM</td></tr><tr><td>local truncation</td><td>$$ O(h^2) $$</td></tr><tr><td>global error</td><td>$$ O(h) $$</td></tr><tr><td>strong/weak 관점</td><td>SDE 변형에서는 strong order ~0.5, weak order ~1(전형적 EM 해석)</td></tr><tr><td>stability 메모</td><td>작은 step에서는 안정적이나, 거친 스텝에서 bias가 빠르게 증가</td></tr></tbody></table><div class='formula'>$$\mathcal{L}_t\varphi=b_t\cdot\nabla\varphi+\frac12 g_t^2\Delta\varphi,\quad \partial_t\rho_t=\mathcal{L}_t^\star\rho_t$$</div><div class='formula'>$$\rho_{k+1}\approx\arg\min_\rho\left(\frac{W_2^2(\rho,\rho_k)}{2\tau_k}+\mathcal{F}(\rho)\right)$$</div><div class='formula'>$$\|x(t_{k+1})-x_{k+1}\|\le C h_k^{p+1},\quad \|x(T)-x_N\|\le C\max_k h_k^p,\quad h_k:=|\lambda_{k+1}-\lambda_k|$$</div><h3>수치해석/구현 관점</h3><table><thead><tr><th>구현 항목</th><th>내용</th></tr></thead><tbody><tr><td>스텝 커널 구조</td><td>$$x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</td></tr><tr><td>모델 평가량(경향)</td><td>대체로 step당 모델 평가 1회(히스토리 결합 비용은 별도).</td></tr><tr><td>history 버퍼</td><td>명시적 history 버퍼 의존이 낮은 단일스텝 구조.</td></tr><tr><td>스텝 제어</td><td>고정 mesh 위에서 noise injection 파라미터(eta, s_noise 등)로 분산 제어.</td></tr><tr><td>메쉬 변수</td><td>$$\lambda=\log\alpha-\log\sigma,\ h_k=|\lambda_{k+1}-\lambda_k|$$</td></tr><tr><td>저장/정밀도 메모</td><td>기본 latent + 중간 stage 텐서 저장 비용이 주된 메모리 사용처.</td></tr></tbody></table><div class='formula'>$$\lambda=\log\alpha-\log\sigma,\quad x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</div><div class='formula'>$$v_{\mathrm{cfg}}=v_u+w(v_c-v_u)$$</div><div class='formula'>$$x_{k+1}=m_k(x_k)+G_k\xi_k,\ \xi_k\sim\mathcal{N}(0,I),\ \mathrm{Cov}[x_{k+1}|x_k]=G_kG_k^\top$$</div><p class='small'><strong>family:</strong> Euler / <strong>stochastic:</strong> yes</p><h2>유도 스케치(순수수학) / 구현 절차(수치해석)</h2><p class='small'><strong>대상:</strong> <code>euler_ancestral</code> / <strong>family:</strong> Euler</p><h3>순수수학 유도 스케치</h3><div class='formula'>$$x_{k+1}=x_k+\mathcal{I}_k^{(drift)}+\mathcal{C}_k^{(history)}+\mathcal{N}_k^{(noise)}$$</div><p class='small'>이 항 분해에서 drift/correction/noise를 어떤 차수로 근사하는지가 sampler family의 본질이다.</p><h3>수치해석 구현 절차</h3><ol class='list'><li>scheduler로 mesh를 고정한 뒤 stepper를 선택한다.</li><li>history 버퍼와 모델 평가 횟수의 비용-정확도 균형을 맞춘다.</li><li>필요 시 stochastic 항을 조절해 분산과 구조 보존을 트레이드오프한다.</li></ol><p class='path'><strong>ComfyUI 경로:</strong> <code>comfy/k_diffusion/sampling.py::sample_euler_ancestral</code></p><p class='path'><strong>독립 구현 전략:</strong> standalone_sampler_lab/samplers.py에 구현됨</p><h2>기호 계약(정의역/공역/조건)</h2><p class='small'>기호별 상세 위키: <a class='row-link' href='../symbol/index.html'><strong>Symbol Wiki Index</strong></a></p><div class='topnav'><a class="btn" href="../symbol/X.html">$\mathcal{X}$</a><a class="btn" href="../symbol/Sigma.html">$\Sigma$</a><a class="btn" href="../symbol/D_theta.html">$D_\theta$</a><a class="btn" href="../symbol/Phi_k.html">$\Phi_k$</a><a class="btn" href="../symbol/Psi_k.html">$\Psi_k$</a><a class="btn" href="../symbol/S_map.html">$S$</a><a class="btn" href="../symbol/Xi_k.html">$\xi_k$</a><a class="btn" href="../symbol/Fk.html">$\mathcal{F}_k$</a><a class="btn" href="../symbol/Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><table><thead><tr><th>항목</th><th>수식</th><th>설명</th></tr></thead><tbody><tr><td>상태 변수</td><td>$x_k:(\Omega,\mathcal{F}_k)\to(\mathcal{X},\mathcal{B}(\mathcal{X}))$</td><td>$\mathcal{X}$는 보통 $\mathbb{R}^d$ (유한차원 힐베르트 공간).</td></tr><tr><td>조건 변수</td><td>$c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})$ 또는 고정 매개변수 $c\in\mathcal{C}$</td><td>조건은 가측 사상 또는 상수 매개변수로 모델링.</td></tr><tr><td>스케줄 사상</td><td>$S:\{0,\dots,N\}\to\Sigma$, $k\mapsto\sigma_k$</td><td>단조감소 가정이 일반적이며 $h_k=|\lambda_{k+1}-\lambda_k|$가 오차를 지배.</td></tr><tr><td>모형 사상</td><td>$D_\theta:(\mathcal{X}\times\Sigma\times\mathcal{C})\to\mathcal{X}$</td><td>측도론적으로는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{B}(\Sigma)\otimes\mathcal{G},\mathcal{B}(\mathcal{X}))$-가측 사상.</td></tr><tr><td>이산시간 전이 사상</td><td>$\Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X}$</td><td>시간지수 $k$에서 $k+1$로 가는 상태전이 사상.</td></tr><tr><td>다단계 과거값 갱신 사상</td><td>$\Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1}$</td><td>과거값 벡터를 다음 단계의 과거값 벡터로 옮기는 사상.</td></tr><tr><td>적응성/가측성</td><td>$x_k$는 $\mathcal{F}_k$-가측, $\Phi_k$는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{A}_k\otimes\mathcal{F}_k,\mathcal{B}(\mathcal{X}))$-가측</td><td>미래 잡음 미참조(non-anticipative) 조건을 형식화.</td></tr><tr><td>기저 확률공간</td><td>$\Omega=(\mathbb{R}^d)^N$, $\mathcal{F}=\mathcal{B}(\Omega)$, $\mathbb{P}=\bigotimes_{k=0}^{N-1}\mathcal{N}(0,I_d)$</td><td>이산 stochastic sampler의 표준 곱측도 모델.</td></tr><tr><td>잡음 확률변수</td><td>$\xi_k:(\Omega,\mathcal{F},\mathbb{P})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))$, $\xi_k\sim\mathcal{N}(0,I_d)$</td><td>$\xi_k\in L^2(\Omega;\mathbb{R}^d)$. 상관잡음이면 공분산 연산자를 명시해야 함.</td></tr><tr><td>필트레이션</td><td>$\mathcal{F}_k=\sigma(\xi_0,\dots,\xi_{k-1})$ 및 $x_k$의 $\mathcal{F}_k$-가측성</td><td>현재 상태가 과거 정보에만 의존한다는 적응성 조건.</td></tr><tr><td>접두 경로공간</td><td>$\Omega_k=(\mathbb{R}^d)^k$</td><td>k-step까지 사용한 난수 경로를 나타내는 부분공간.</td></tr></tbody></table><p class='small'>해석 팁: <code>k</code>는 이산 step index, <code>t</code>는 연속시간 변수로 구분한다. 또한 $\mathcal{X}\times\mathcal{H}_k\times\Omega_k$ 위에서 정의된 $\Phi_k$의 가측성은 코드에서 난수 소비 순서(시드 재현성)와 직접 연결된다.</p><h3>직관/구체 원소 예시</h3><table><thead><tr><th>기호</th><th>원소 예시</th><th>직관</th></tr></thead><tbody><tr><td>$x_k\in\mathcal{X}$</td><td>$d=4$ 예시에서 $x_k=(0.12,-0.34,1.08,0.00)$</td><td>현재 latent 상태의 한 점.</td></tr><tr><td>$h_k\in\mathcal{H}_k$</td><td>2-step이면 $h_k=(x_{k-1},x_k)$</td><td>다단계 solver의 과거값 벡터.</td></tr><tr><td>$\Phi_k$</td><td>$x_{k+1}=\Phi_k(x_k,h_k,\omega_k)$</td><td>한 step에서 상태를 다음 상태로 보내는 사상.</td></tr><tr><td>$\Psi_k$</td><td>$\Psi_k((x_{k-1},x_k),x_{k+1})=(x_k,x_{k+1})$</td><td>슬라이딩 윈도우 형태의 과거값 갱신.</td></tr><tr><td>$\omega\in\Omega$</td><td>$\omega=(\xi_0,\xi_1,\dots,\xi_{N-1})$</td><td>전체 샘플링 과정에서 소비될 난수 경로 하나.</td></tr><tr><td>$\xi_k$</td><td>$d=3$ 예시: $\xi_k=(0.31,-1.24,0.08)$</td><td>k번째 step의 가우시안 잡음 벡터.</td></tr></tbody></table><h3>해당 sampler의 추가 제약</h3><table><thead><tr><th>제약</th><th>조건</th><th>의미</th></tr></thead><tbody><tr><td>mesh 단조성</td><td>$\sigma_{k+1}\le\sigma_k$, $h_k:=|\lambda_{k+1}-\lambda_k|>0$</td><td>역적분 안정성 및 오차 분석의 기본 가정.</td></tr><tr><td>drift 정칙성</td><td>$\|b_\theta(x,t)-b_\theta(y,t)\|\le L\|x-y\|$</td><td>존재/유일성과 수치해석 수렴률에 필요한 대표 가정.</td></tr><tr><td>확률강도</td><td>$\eta\ge0$</td><td>noise 주입 강도/드리프트 감쇠 결합.</td></tr><tr><td>노이즈 배율</td><td>$s_{noise}\ge0$</td><td>분산 스케일 파라미터.</td></tr></tbody></table><h2>공통 인자(시그니처 공통부)</h2><table><thead><tr><th>인자</th><th>타입/의미</th><th>역할</th></tr></thead><tbody><tr><td><code>model</code></td><td>denoiser callable</td><td>모델 함수</td></tr><tr><td><code>x</code></td><td>latent</td><td>현재 상태</td></tr><tr><td><code>sigmas</code></td><td>sigma schedule</td><td>스텝별 노이즈 스케일</td></tr><tr><td><code>extra_args</code></td><td>dict</td><td>seed/model_options 등 추가 인자</td></tr><tr><td><code>callback</code></td><td>callable</td><td>진행 콜백</td></tr><tr><td><code>disable</code></td><td>bool</td><td>progress disable</td></tr></tbody></table><h2>sampler 고유 파라미터 상세</h2><table><thead><tr><th>파라미터</th><th>기본값</th><th>수학/알고리즘 역할</th><th>KSampler 노출 경로</th></tr></thead><tbody><tr><td><code>eta</code></td><td><code>1.</code></td><td>확률항 강도 및 drift 감쇠에 반영</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>s_noise</code></td><td><code>1.</code></td><td>noise term 배수</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr><tr><td><code>noise_sampler</code></td><td><code>None</code></td><td>코드 레벨 노이즈 샘플러 함수 주입</td><td>코드 레벨 파라미터.</td></tr></tbody></table><h2>파라미터-수식 기호 대응</h2><table><thead><tr><th>코드 파라미터</th><th>수식 기호</th><th>들어가는 항</th><th>해석</th></tr></thead><tbody><tr><td><code>model</code></td><td>$$ \hat{x}_0(\cdot;\theta,c) $$</td><td>drift 항</td><td>denoiser/score 기반 추정기</td></tr><tr><td><code>x</code></td><td>$$ x_k $$</td><td>상태 변수</td><td>현재 latent 상태</td></tr><tr><td><code>sigmas</code></td><td>$$ \{\sigma_k\}_{k=0}^{N} $$</td><td>시간 재매개화</td><td>노이즈 스케줄 격자</td></tr><tr><td><code>extra_args</code></td><td>$$ c,\ \text{options} $$</td><td>조건 벡터장</td><td>conditioning/옵션 전달</td></tr><tr><td><code>callback</code></td><td>$$ \mathcal{C}_k $$</td><td>관측 함수</td><td>수치 궤적 모니터링</td></tr><tr><td><code>disable</code></td><td>$$ - $$</td><td>UI/로그 제어</td><td>수학 항에는 직접 미참여</td></tr><tr><td><code>eta</code></td><td>$$ \eta $$</td><td>diffusion 강도</td><td>노이즈 주입 강도 및 drift 감쇠와 결합</td></tr><tr><td><code>s_noise</code></td><td>$$ s_{\text{noise}} $$</td><td>noise 스케일</td><td>\xi_k \mapsto s_{\text{noise}}\xi_k</td></tr><tr><td><code>noise_sampler</code></td><td>$$ noise_sampler $$</td><td>구현 의존</td><td>sampler-specific tuning parameter</td></tr></tbody></table><h2>원본 구현 스니펫</h2><div class='codebox'>def sample_euler_ancestral(model, x, sigmas, extra_args=None, callback=None, disable=None, eta=1., s_noise=1., noise_sampler=None):
    if isinstance(model.inner_model.inner_model.model_sampling, comfy.model_sampling.CONST):
        return sample_euler_ancestral_RF(model, x, sigmas, extra_args, callback, disable, eta, s_noise, noise_sampler)
    """Ancestral sampling with Euler method steps."""
    extra_args = {} if extra_args is None else extra_args
    seed = extra_args.get("seed", None)
    noise_sampler = default_noise_sampler(x, seed=seed) if noise_sampler is None else noise_sampler
    s_in = x.new_ones([x.shape[0]])
    for i in trange(len(sigmas) - 1, disable=disable):
        denoised = model(x, sigmas[i] * s_in, **extra_args)
        sigma_down, sigma_up = get_ancestral_step(sigmas[i], sigmas[i + 1], eta=eta)
        if callback is not None:
            callback({'x': x, 'i': i, 'sigma': sigmas[i], 'sigma_hat': sigmas[i], 'denoised': denoised})

        if sigma_down == 0:
            x = denoised</div><div class="topnav"><a class="btn" href="euler_cfg_pp.html">이전: euler_cfg_pp</a><a class="btn" href="euler_ancestral_cfg_pp.html">다음: euler_ancestral_cfg_pp</a></div></article></div></body></html>