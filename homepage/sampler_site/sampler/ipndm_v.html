<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sampler: ipndm_v</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="../index.html#top">최상위 문서</a><a class="btn" href="../index.html#integrated-model">통합 관점</a><a class="btn" href="../index.html#bridge">KSampler 브리지</a><a class="btn" href="../symbol/index.html">기호 위키</a><a class="btn" href="../index.html#sampler-catalog">Sampler Catalog</a></div><h1>Sampler: <code>ipndm_v</code></h1><div class="chips"><span class="chip">family: N-DM / DEIS</span><span class="chip">stochastic: no</span><span class="chip">cfg_pp: no</span><span class="chip">gpu_variant: no</span><span class="chip">standalone: no</span></div><p><strong>ComfyUI 함수 시그니처</strong><br><code>sample_ipndm_v(model, x, sigmas, extra_args=None, callback=None, disable=None, max_order=4)</code></p><div class='formula'>$$ x_{k+1}=\Phi(x_k,\sigma_k,\sigma_{k+1}) $$</div><p>이력 기반 다단계 적분. 초기 워밍업 구간은 저차로 시작하고, 이후 이력 버퍼가 쌓이면서 고차 근사가 활성화된다.</p><p>결정론 경로로 보면 확산항이 제거된 continuity equation 관점: $\partial_t\rho+\nabla\cdot(\rho v)=0$. 동적 OT(Benamou-Brenier) 형태의 수송 해석이 용이하다.</p><h2>수학 심화 프로파일</h2><h3>순수수학 관점</h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>method class</td><td>history 기반 multistep</td></tr><tr><td>local truncation</td><td>$$ O(h^{m+1}) $$</td></tr><tr><td>global error</td><td>$$ O(h^m) $$</td></tr><tr><td>strong/weak 관점</td><td>초기 warm-up 구간에서는 유효 차수가 낮고 이후 history 축적으로 상승</td></tr><tr><td>stability 메모</td><td>메쉬 불균일이 크면 계수 조건수가 악화될 수 있어 스케줄과 동시 튜닝 필요</td></tr></tbody></table><div class='formula'>$$\mathcal{L}_t\varphi=v_t\cdot\nabla\varphi,\quad \partial_t\rho_t+\nabla\cdot(\rho_t v_t)=0$$</div><div class='formula'>$$\min_{\rho,v}\int_0^1\!\!\int \frac12\|v_t(x)\|^2\rho_t(x)\,dx\,dt,\quad \partial_t\rho+\nabla\cdot(\rho v)=0$$</div><div class='formula'>$$\|x(t_{k+1})-x_{k+1}\|\le C h_k^{p+1},\quad \|x(T)-x_N\|\le C\max_k h_k^p,\quad h_k:=|\lambda_{k+1}-\lambda_k|$$</div><h3>수치해석/구현 관점</h3><table><thead><tr><th>구현 항목</th><th>내용</th></tr></thead><tbody><tr><td>스텝 커널 구조</td><td>$$x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</td></tr><tr><td>모델 평가량(경향)</td><td>대체로 step당 모델 평가 1회(히스토리 결합 비용은 별도).</td></tr><tr><td>history 버퍼</td><td>차수 m에 비례하는 history 버퍼(최근 gradient/derivative)를 유지한다.</td></tr><tr><td>스텝 제어</td><td>고정 mesh의 deterministic stepper 제어.</td></tr><tr><td>메쉬 변수</td><td>$$\lambda=\log\alpha-\log\sigma,\ h_k=|\lambda_{k+1}-\lambda_k|$$</td></tr><tr><td>저장/정밀도 메모</td><td>history 버퍼 메모리와 계수 연산(벡터화) 비용이 핵심.</td></tr></tbody></table><div class='formula'>$$\lambda=\log\alpha-\log\sigma,\quad x_{k+1}=A_kx_k+B_k\hat{x}_{0,k}+C_k(\text{history})+D_k\xi_k$$</div><div class='formula'>$$v_{\mathrm{cfg}}=v_u+w(v_c-v_u)$$</div><div class='formula'>$$x_{k+1}=m_k(x_k),\quad \partial_t\rho+\nabla\cdot(\rho v)=0$$</div><p class='small'><strong>family:</strong> N-DM / DEIS / <strong>stochastic:</strong> no</p><h2>유도 스케치(순수수학) / 구현 절차(수치해석)</h2><p class='small'><strong>대상:</strong> <code>ipndm_v</code> / <strong>family:</strong> N-DM / DEIS</p><h3>순수수학 유도 스케치</h3><div class='formula'>$$x_{k+1}=x_k+\mathcal{I}_k^{(drift)}+\mathcal{C}_k^{(history)}+\mathcal{N}_k^{(noise)}$$</div><p class='small'>이 항 분해에서 drift/correction/noise를 어떤 차수로 근사하는지가 sampler family의 본질이다.</p><h3>수치해석 구현 절차</h3><ol class='list'><li>scheduler로 mesh를 고정한 뒤 stepper를 선택한다.</li><li>history 버퍼와 모델 평가 횟수의 비용-정확도 균형을 맞춘다.</li><li>필요 시 stochastic 항을 조절해 분산과 구조 보존을 트레이드오프한다.</li></ol><p class='path'><strong>ComfyUI 경로:</strong> <code>comfy/k_diffusion/sampling.py::sample_ipndm_v</code></p><p class='path'><strong>독립 구현 전략:</strong> 현재는 comfy_native 위임 권장(후속 standalone 확장)</p><h2>기호 계약(정의역/공역/조건)</h2><p class='small'>기호별 상세 위키: <a class='row-link' href='../symbol/index.html'><strong>Symbol Wiki Index</strong></a></p><div class='topnav'><a class="btn" href="../symbol/X.html">$\mathcal{X}$</a><a class="btn" href="../symbol/Sigma.html">$\Sigma$</a><a class="btn" href="../symbol/D_theta.html">$D_\theta$</a><a class="btn" href="../symbol/Phi_k.html">$\Phi_k$</a><a class="btn" href="../symbol/Psi_k.html">$\Psi_k$</a><a class="btn" href="../symbol/S_map.html">$S$</a><a class="btn" href="../symbol/Xi_k.html">$\xi_k$</a><a class="btn" href="../symbol/Fk.html">$\mathcal{F}_k$</a><a class="btn" href="../symbol/Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><table><thead><tr><th>항목</th><th>수식</th><th>설명</th></tr></thead><tbody><tr><td>상태 변수</td><td>$x_k:(\Omega,\mathcal{F}_k)\to(\mathcal{X},\mathcal{B}(\mathcal{X}))$</td><td>$\mathcal{X}$는 보통 $\mathbb{R}^d$ (유한차원 힐베르트 공간).</td></tr><tr><td>조건 변수</td><td>$c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})$ 또는 고정 매개변수 $c\in\mathcal{C}$</td><td>조건은 가측 사상 또는 상수 매개변수로 모델링.</td></tr><tr><td>스케줄 사상</td><td>$S:\{0,\dots,N\}\to\Sigma$, $k\mapsto\sigma_k$</td><td>단조감소 가정이 일반적이며 $h_k=|\lambda_{k+1}-\lambda_k|$가 오차를 지배.</td></tr><tr><td>모형 사상</td><td>$D_\theta:(\mathcal{X}\times\Sigma\times\mathcal{C})\to\mathcal{X}$</td><td>측도론적으로는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{B}(\Sigma)\otimes\mathcal{G},\mathcal{B}(\mathcal{X}))$-가측 사상.</td></tr><tr><td>이산시간 전이 사상</td><td>$\Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X}$</td><td>시간지수 $k$에서 $k+1$로 가는 상태전이 사상.</td></tr><tr><td>다단계 과거값 갱신 사상</td><td>$\Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1}$</td><td>과거값 벡터를 다음 단계의 과거값 벡터로 옮기는 사상.</td></tr><tr><td>적응성/가측성</td><td>$x_k$는 $\mathcal{F}_k$-가측, $\Phi_k$는 $(\mathcal{B}(\mathcal{X})\otimes\mathcal{A}_k\otimes\mathcal{F}_k,\mathcal{B}(\mathcal{X}))$-가측</td><td>미래 잡음 미참조(non-anticipative) 조건을 형식화.</td></tr><tr><td>결정론적 모델</td><td>$\Omega=\{\omega_0\}$, $\mathcal{F}=\{\varnothing,\Omega\}$, $\mathbb{P}(\Omega)=1$</td><td>확률기호는 형식적으로만 남고 난수항은 제거된다.</td></tr><tr><td>step 사상 축약</td><td>$\Phi_k:\mathcal{X}\times\mathcal{H}_k\to\mathcal{X}$</td><td>난수 인자 $\Omega_k$가 소거된 결정론적 사상으로 동작.</td></tr><tr><td>다단계 곱공간</td><td>$\mathcal{H}_k=\mathcal{X}^{m_k}$, $\mathcal{A}_k=\mathcal{B}(\mathcal{X})^{\otimes m_k}$, $m_k\le m$</td><td>초기 구간에서는 $m_k$가 작고, 진행되며 최대 차수까지 증가.</td></tr></tbody></table><p class='small'>해석 팁: <code>k</code>는 이산 step index, <code>t</code>는 연속시간 변수로 구분한다. 또한 $\mathcal{X}\times\mathcal{H}_k\times\Omega_k$ 위에서 정의된 $\Phi_k$의 가측성은 코드에서 난수 소비 순서(시드 재현성)와 직접 연결된다.</p><h3>직관/구체 원소 예시</h3><table><thead><tr><th>기호</th><th>원소 예시</th><th>직관</th></tr></thead><tbody><tr><td>$x_k\in\mathcal{X}$</td><td>$d=4$ 예시에서 $x_k=(0.12,-0.34,1.08,0.00)$</td><td>현재 latent 상태의 한 점.</td></tr><tr><td>$h_k\in\mathcal{H}_k$</td><td>2-step이면 $h_k=(x_{k-1},x_k)$</td><td>다단계 solver의 과거값 벡터.</td></tr><tr><td>$\Phi_k$</td><td>$x_{k+1}=\Phi_k(x_k,h_k,\omega_k)$</td><td>한 step에서 상태를 다음 상태로 보내는 사상.</td></tr><tr><td>$\Psi_k$</td><td>$\Psi_k((x_{k-1},x_k),x_{k+1})=(x_k,x_{k+1})$</td><td>슬라이딩 윈도우 형태의 과거값 갱신.</td></tr><tr><td>결정론적 경우</td><td>$\Omega=\{\omega_0\}$</td><td>난수 경로가 하나뿐이라 잡음항이 사라짐.</td></tr></tbody></table><h3>해당 sampler의 추가 제약</h3><table><thead><tr><th>제약</th><th>조건</th><th>의미</th></tr></thead><tbody><tr><td>mesh 단조성</td><td>$\sigma_{k+1}\le\sigma_k$, $h_k:=|\lambda_{k+1}-\lambda_k|>0$</td><td>역적분 안정성 및 오차 분석의 기본 가정.</td></tr><tr><td>drift 정칙성</td><td>$\|b_\theta(x,t)-b_\theta(y,t)\|\le L\|x-y\|$</td><td>존재/유일성과 수치해석 수렴률에 필요한 대표 가정.</td></tr></tbody></table><h2>공통 인자(시그니처 공통부)</h2><table><thead><tr><th>인자</th><th>타입/의미</th><th>역할</th></tr></thead><tbody><tr><td><code>model</code></td><td>denoiser callable</td><td>모델 함수</td></tr><tr><td><code>x</code></td><td>latent</td><td>현재 상태</td></tr><tr><td><code>sigmas</code></td><td>sigma schedule</td><td>스텝별 노이즈 스케일</td></tr><tr><td><code>extra_args</code></td><td>dict</td><td>seed/model_options 등 추가 인자</td></tr><tr><td><code>callback</code></td><td>callable</td><td>진행 콜백</td></tr><tr><td><code>disable</code></td><td>bool</td><td>progress disable</td></tr></tbody></table><h2>sampler 고유 파라미터 상세</h2><table><thead><tr><th>파라미터</th><th>기본값</th><th>수학/알고리즘 역할</th><th>KSampler 노출 경로</th></tr></thead><tbody><tr><td><code>max_order</code></td><td><code>4</code></td><td>최대 이력 차수</td><td>Basic KSampler 미노출. Custom Sampling 노드/코드(extra_options)에서 제어.</td></tr></tbody></table><h2>파라미터-수식 기호 대응</h2><table><thead><tr><th>코드 파라미터</th><th>수식 기호</th><th>들어가는 항</th><th>해석</th></tr></thead><tbody><tr><td><code>model</code></td><td>$$ \hat{x}_0(\cdot;\theta,c) $$</td><td>drift 항</td><td>denoiser/score 기반 추정기</td></tr><tr><td><code>x</code></td><td>$$ x_k $$</td><td>상태 변수</td><td>현재 latent 상태</td></tr><tr><td><code>sigmas</code></td><td>$$ \{\sigma_k\}_{k=0}^{N} $$</td><td>시간 재매개화</td><td>노이즈 스케줄 격자</td></tr><tr><td><code>extra_args</code></td><td>$$ c,\ \text{options} $$</td><td>조건 벡터장</td><td>conditioning/옵션 전달</td></tr><tr><td><code>callback</code></td><td>$$ \mathcal{C}_k $$</td><td>관측 함수</td><td>수치 궤적 모니터링</td></tr><tr><td><code>disable</code></td><td>$$ - $$</td><td>UI/로그 제어</td><td>수학 항에는 직접 미참여</td></tr><tr><td><code>max_order</code></td><td>$$ m_{\max} $$</td><td>최대 차수</td><td>적응형/다단계 상한</td></tr></tbody></table><h2>원본 구현 스니펫</h2><div class='codebox'>def sample_ipndm_v(model, x, sigmas, extra_args=None, callback=None, disable=None, max_order=4):
    extra_args = {} if extra_args is None else extra_args
    s_in = x.new_ones([x.shape[0]])

    x_next = x
    t_steps = sigmas

    buffer_model = []
    for i in trange(len(sigmas) - 1, disable=disable):
        t_cur = sigmas[i]
        t_next = sigmas[i + 1]

        x_cur = x_next

        denoised = model(x_cur, t_cur * s_in, **extra_args)
        if callback is not None:</div><div class="topnav"><a class="btn" href="ipndm.html">이전: ipndm</a><a class="btn" href="deis.html">다음: deis</a></div></article></div></body></html>