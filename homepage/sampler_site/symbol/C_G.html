<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: C_G</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $(\mathcal{C},\mathcal{G})$</h1><p class='muted'><strong>조건변수 가측공간 (Measurable conditioning space)</strong></p><h2>모티베이션 (Motivation)</h2><p>프롬프트/컨트롤 같은 ‘조건 입력’ $c$가 어떤 값들을 가질 수 있는지(공간 $\mathcal{C}$)와, 그 위에서 확률/가측성을 말하기 위한 $\sigma$-대수 $\mathcal{G}$를 묶어 $(\mathcal{C},\mathcal{G})$로 적는다.</p><ol class='list'><li>ComfyUI에서 ‘조건(conditioning)’은 텍스트 프롬프트(<code>positive/negative</code>), ControlNet의 컨트롤 신호, IPAdapter/참조 이미지 특징, 각종 메타데이터까지 한데 묶인 입력이다. 이들을 $c\in\mathcal{C}$로 보고 $D_\theta(x,\sigma,c)$처럼 표기하면, “모델은 상태/노이즈/조건을 받아 같은 공간의 벡터를 돌려준다”는 타입이 고정돼 구현과 수학이 같이 정리된다.</li><li>CFG(Classifier-Free Guidance)는 같은 $x,\sigma$에서 조건 $c$와 비조건(보통 ‘빈 프롬프트’) $c_{\emptyset}$를 동시에 평가해서 두 출력을 선형결합한다. 이때 $c$와 $c_{\emptyset}$가 같은 값공간 $\mathcal{C}$의 원소라는 점이 핵심이며, 그렇지 않으면 CFG 공식 자체가 타입이 맞지 않는다.</li><li>프롬프트를 step에 따라 바꾸는 ‘프롬프트 스케줄’, 영상에서 프레임별로 다른 조건을 주는 작업은 사실상 $k\mapsto c_k$ 또는 $t\mapsto c(t)$를 설계하는 것이다. $(\mathcal{C},\mathcal{G})$를 명시하면 “조건이 바뀌는 축”과 “노이즈가 줄어드는 축($\sigma$)”을 혼동하지 않고 설명할 수 있다.</li><li>편집(inpaint, reference 기반 생성)에서는 조건이 단순 텍스트가 아니라 ‘고정해야 할 정보’를 포함한다(마스크, 참조 특징, 깊이맵 등). 이를 $c$에 포함시키면, 샘플러는 동일한 전이 규칙을 쓰되 조건만 바꿔 다양한 편집 파이프라인을 한 언어로 설명할 수 있다.</li><li>조건을 고정 파라미터로 둘 수도 있고(대부분의 UI 추론), 데이터셋에서 랜덤으로 뽑는 확률변수로 둘 수도 있다(학습/증강). $(\mathcal{C},\mathcal{G})$를 두면 이 두 관점을 같은 문법 안에서 오가며 쓸 수 있다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{C}\ \text{(value space)},\qquad \mathcal{G}\subseteq 2^{\mathcal{C}}\ \text{($\sigma$-algebra)} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})\ \text{measurable} $$</div></div><div class='box'><p class='small'><strong>정의 3.</strong></p><div class='formula'>$$ c\in\mathcal{C}\ \text{(fixed parameter)} $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 “조건값이 어떤 형태의 대상인지”를 고정한다. 가장 흔한 경우는 $\mathcal{C}=\mathbb{R}^n$ 같은 유한차원 실수공간(임베딩 벡터)이다.</p><p>둘째 문장은 조건이 랜덤일 수도 있다는 점을 포함한다. 예를 들어 데이터셋에서 조건을 랜덤으로 뽑거나, 조건 자체가 노이즈를 포함하는 파이프라인이면 $c$를 확률변수로 보는 게 자연스럽다.</p><p>반대로 대부분의 UI/추론에서는 조건을 고정하고 샘플링만 랜덤으로 한다. 그때는 $c\in\mathcal{C}$인 상수 매개변수로 보고, 가측성 문장은 배경 가정으로만 남는다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{C}\ \text{(value space)},\qquad \mathcal{G}\subseteq 2^{\mathcal{C}}\ \text{($\sigma$-algebra)} $$</div><h3>해설</h3><ol class='list'><li>$\mathcal{C}$는 조건값이 들어갈 ‘값공간’이다. 텍스트 임베딩이라면 보통 $\mathbb{R}^n$, 범주형 라벨이면 유한 집합 $\{1,\dots,K\}$ 같은 형태가 된다.</li><li>$\mathcal{G}$는 조건값에 대해 ‘사건’을 말하기 위한 집합족이다. $\mathcal{C}=\mathbb{R}^n$이면 대개 $\mathcal{G}=\mathcal{B}(\mathbb{R}^n)$로 둔다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>조건도 결국 어떤 ‘데이터 타입’이다. $\mathcal{C}$는 그 타입의 수학적 이름이라고 보면 된다.</li></ol><h3>수치 예시</h3><ol class='list'><li>예: $\mathcal{C}=\mathbb{R}^2$, $c=(1.5,-0.3)$.</li><li>예: $\mathcal{C}=\{1,2,3\}$ (3가지 라벨), $\mathcal{G}=2^{\mathcal{C}}$.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ c:(\Omega,\mathcal{F})\to(\mathcal{C},\mathcal{G})\ \text{measurable} $$</div><h3>해설</h3><ol class='list'><li>조건을 확률변수로 두면, 각 난수 시나리오 $\omega$에 대해 조건값 $c(\omega)$가 정해진다.</li><li>가측성은 “조건에 대한 관측/사건이 표본공간 사건으로 옮겨진다”는 최소한의 일관성 조건이다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>데이터셋에서 조건을 랜덤으로 뽑는다면, ‘그 랜덤 선택’ 자체가 $c(\omega)$다.</li></ol><h3>수치 예시</h3><ol class='list'><li>유한 예: $\Omega=\{1,2\}$, $\mathbb{P}(1)=\mathbb{P}(2)=0.5$. $c(1)=(0,0)$, $c(2)=(1,0)$ (조건공간 $\mathbb{R}^2$).</li></ol></div><div class='box'><p class='small'><strong>정의 3.</strong></p><div class='formula'>$$ c\in\mathcal{C}\ \text{(fixed parameter)} $$</div><h3>해설</h3><ol class='list'><li>추론/UI에서는 보통 조건을 고정한다. 이 경우 $c$는 확률변수가 아니라 단순한 상수 매개변수다.</li><li>그래도 $(\mathcal{C},\mathcal{G})$를 정의해 두면 “조건을 바꾸면 다른 문제를 푼다”는 구조가 명확해진다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>프롬프트를 바꾸는 건 $c$를 바꾸는 것이고, 같은 샘플러라도 다른 경로를 걷게 된다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$c=(0.2,0.2)$를 고정해 두면 모든 step에서 같은 값을 넣는다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>조건은 ‘문제 설정’을 바꾸는 외생 입력이다. 같은 노이즈 $x$라도 조건 $c$가 달라지면 모델이 다른 방향을 제시한다.</li><li>실무에선 조건이 텍스트 임베딩/이미지 피처/컨트롤 신호 등 ‘실수 벡터’인 경우가 많다.</li><li>추론(inference)에서는 보통 $c$를 고정 매개변수로 두고, 난수는 $\xi_k$에서만 들어온다. 따라서 “같은 조건 $c$에서 seed만 바꿔 여러 결과를 뽑는다”는 말은 $\rho_t(\cdot\mid c)$에서의 샘플링을 뜻한다.</li><li>ComfyUI의 CFG는 같은 $(x,\sigma)$에서 조건 $c$와 비조건 $c_\emptyset$를 각각 넣어 $D_\theta$를 두 번 평가하고, <code>cfg</code>로 두 출력을 affine combination 한다. 수학적으로는 “조건이 벡터장을 어떻게 바꾸는가”를 가장 직접적으로 보여 주는 구현이다.</li><li>코드 구현 관점에선 조건 객체가 복잡해 보여도(positive/negative, control, ipadapter 등), 샘플러 입장에서는 결국 <code>cond</code> 인자 하나로 들어오며 ‘값공간 $\mathcal{C}$의 한 원소’로 취급된다. 그래서 커스텀 샘플러는 $\mathcal{C}$의 내부 표현을 몰라도 된다(인터페이스 분리).</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>가장 단순히 $\mathcal{C}=\mathbb{R}^2$로 두고 $c=(1.5,\,-0.3)\in\mathcal{C}$ 같은 벡터를 조건으로 쓸 수 있다.</li><li>조건을 고정하면 $c$는 상수다. 예: 모든 step에서 동일하게 $c=(0.2,0.2)$를 넣는다.</li><li>(CFG 수치 예) 어떤 $(x,\sigma)$에서 $D_\theta(x,\sigma,c)=(1.0,\,2.0)$, $D_\theta(x,\sigma,c_\emptyset)=(0.2,\,1.5)$라고 하자. <code>cfg=7</code>이면 guided 출력은 $(0.2,1.5)+7\cdot((1.0,2.0)-(0.2,1.5))=(5.8,\,5.0)$처럼 차이가 크게 증폭된다.</li><li>(쌍 조건 예) $\mathcal{C}=\mathbb{R}^2\times\mathbb{R}^2$로 두고 $c=(c^+,c^-)$. 예: $c^+=(1.0,0.0)$, $c^-=(0.0,1.0)$이면 $c=((1.0,0.0),(0.0,1.0))\in\mathcal{C}$.</li><li>(조건 스케줄 예) $N=4$일 때 $c_0=(1,0)$, $c_1=(1,0)$, $c_2=(0,1)$, $c_3=(0,1)$처럼 step에 따라 조건을 바꾸면 “절반은 A 조건, 절반은 B 조건” 같은 스케줄을 수학적으로 $k\mapsto c_k$로 쓸 수 있다.</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>model(x, sigma, cond)</code>의 <code>cond</code> 인자가 여기에 해당한다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>조건 공간/가측성 가정을 생략하면 조건부 표기 $p(x|c)$의 수학적 의미가 흐려진다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="D_theta.html">$D_\theta$</a><a class="btn" href="b_theta.html">$b_\theta$</a></div><div class="topnav"><a class="btn" href="Sigma.html">이전: $\Sigma$</a><a class="btn" href="Hk_Ak.html">다음: $(\mathcal{H}_k,\mathcal{A}_k)$</a></div></article></div></body></html>