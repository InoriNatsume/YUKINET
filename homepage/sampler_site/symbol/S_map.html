<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: S_map</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $S$</h1><p class='muted'><strong>스케줄 사상 (Schedule map)</strong></p><h2>모티베이션 (Motivation)</h2><p>step index $k=0,1,\dots,N$을 노이즈 스케일 $\sigma_k$로 바꿔 주는 함수(또는 룩업 테이블)를 $S$라고 쓴다. 코드에서는 <code>sigmas[k]</code>를 돌려주는 것과 같다.</p><ol class='list'><li>ComfyUI에서 <code>scheduler</code> 선택은 곧 “step 인덱스 $k$를 어떤 $\sigma_k$로 매핑할지”를 고르는 일이다. 같은 <code>sampler_name</code>이라도 <code>scheduler</code>를 바꾸면 결과가 크게 달라지는 이유는, 실제로 모델을 평가하는 지점들이 바뀌기 때문이다.</li><li>수치해석 관점에서 $S$는 적분 그리드(mesh)다. Euler/Heun/DPM++ 같은 solver가 동일해도, 그리드가 달라지면 국소 오차가 어느 구간에 집중되는지(전역 구조 vs 미세 디테일)가 달라진다. 그래서 실무에서는 sampler와 scheduler를 분리된 옵션이 아니라 ‘한 쌍’으로 보는 편이 맞다.</li><li><code>steps</code>는 정의역의 크기 $N$을 정하고, $S$는 각 step의 실질적인 step-size(예: $\Delta\sigma=\sigma_{k+1}-\sigma_k$)를 정한다. 따라서 “steps를 늘렸는데도 품질이 크게 안 좋아진다/오히려 나빠진다” 같은 현상도 $S$의 배치가 원인일 수 있다.</li><li>img2img/inpaint에서 <code>denoise</code>나 구간 옵션을 쓰면, 사실상 $S$의 일부만 사용한다(큰 $\sigma$ 구간을 생략하거나, 특정 구간만 반복). 이때 어떤 구간을 생략하느냐가 원본 보존/변형 정도를 결정하므로, $S$를 명시적으로 보는 습관이 편집 설계에 도움이 된다.</li><li>논문/코드에서는 시간 $t$와 $\sigma$를 오가며 표기하는데, 실제 구현은 결국 $k\mapsto$ (모델이 요구하는 스케일 변수) 변환이다. $S$를 중심에 두면 “우리 구현은 $\sigma$-매개변수인가, $t$-매개변수인가”가 혼동되지 않는다.</li><li>영상 생성에서는 프레임별로 동일한 $S$를 쓰는지, 혹은 일부 프레임에만 다른 구간을 쓰는지(예: 키프레임만 더 낮은 $\sigma$까지) 같은 설계가 생긴다. 이 역시 $S$를 조작하는 문제로 정리된다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ S:\{0,\dots,N\}\to\Sigma,\qquad S(k)=\sigma_k $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \sigma_{k+1}\le\sigma_k $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 스케줄이 “유한한 룩업 테이블”이라는 뜻이다. 실제 구현에서는 길이 $N+1$인 배열 <code>sigmas</code>가 있고, $S(k)$는 그 배열의 $k$번째 원소다.</p><p>둘째 문장의 단조감소 가정은 ‘노이즈를 줄이며 정제한다’는 해석과 맞아떨어진다. 단조가 깨지면(중간에 $\sigma$가 올라가면) solver가 의도하지 않은 흔들림을 만들 수 있다.</p><p>수치해석 관점에서는, 같은 solver라 해도 mesh(그리드) 선택이 달라지면 오차가 어느 구간에 분배되는지가 바뀐다. 그래서 스케줄러를 ‘solver의 일부’로 보는 게 실무적으로 맞다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ S:\{0,\dots,N\}\to\Sigma,\qquad S(k)=\sigma_k $$</div><h3>해설</h3><ol class='list'><li>정의역 $\{0,\dots,N\}$는 이산 step 인덱스이고, 공역 $\Sigma$는 노이즈 스케일 값공간이다.</li><li>즉 스케줄은 ‘인덱스 → 실수값’ 변환이다. 구현에서는 단순 배열 조회다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>샘플러가 모델을 언제(어떤 $\sigma$에서) 평가하는지의 타임라인이다.</li></ol><h3>수치 예시</h3><ol class='list'><li><code>sigmas=[10,5,2,1,0]</code>면 $S(2)=2$.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \sigma_{k+1}\le\sigma_k $$</div><h3>해설</h3><ol class='list'><li>단조감소는 “점점 노이즈를 줄인다”는 뜻이다. 대부분의 diffusion sampling은 큰 노이즈에서 작은 노이즈로 내려가는 흐름을 전제한다.</li><li>단조감소가 깨지면 어떤 step에서는 노이즈가 다시 커져, solver의 안정성/품질이 떨어질 수 있다(특히 저 step 수에서).</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>사진을 점점 선명하게 만드는 과정에서, 중간에 다시 흐리게 만들면 이상해진다.</li></ol><h3>수치 예시</h3><ol class='list'><li><code>sigmas=[10,4,1,0.2,0]</code>는 단조감소다.</li><li><code>sigmas=[10,4,6,1,0]</code>는 $4\to6$에서 단조감소가 깨진 예다(보통 의도하지 않음).</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>‘$N$번 호출을 어떤 $\sigma$ 위치에 배치할지’를 정하는 시간표다.</li><li>같은 solver라도 스케줄을 바꾸면 체감 품질이 크게 바뀌는 이유가 여기에 있다.</li><li>ComfyUI에서는 <code>steps</code>가 정의역 크기 $N$을, <code>scheduler</code>가 $S$의 구체적인 형태를 정한다. 즉 “sampler는 유지하고 scheduler만 바꾼다”는 말은 $\Phi_k$는 고정하고 $\sigma_k=S(k)$만 바꾸는 것이다.</li><li>코드 구현 관점에선 $S$는 단순 배열 룩업(<code>sigmas[k]</code>)이지만, 수치해석 관점에선 $S$가 곧 step-size/오차/안정성을 좌우한다. 그래서 커스터마이징의 1순위가 되는 경우가 많다.</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>$N=4$일 때 한 예로 $S(0)=10, S(1)=5, S(2)=2, S(3)=1, S(4)=0$처럼 둘 수 있다(즉 <code>sigmas=[10,5,2,1,0]</code>).</li><li>다른 예로 <code>sigmas=[10,4,1,0.2,0]</code>처럼 작은 $\sigma$ 쪽을 더 촘촘히 둘 수도 있다.</li><li>(ComfyUI img2img 예) <code>steps=4</code>, <code>sigmas=[10,5,2,1,0]</code>라고 하자. <code>denoise=0.5</code>를 “앞 절반 생략”으로 단순화하면 시작점을 $\sigma=5$로 잡아 $(5,2,1,0)$만 따라가는 것과 비슷하다(정확한 시작 인덱스는 구현에 따라 다를 수 있음).</li><li>(룩업 예) <code>sigmas=[10,4,1,0.2,0]</code>면 $S(2)=\sigma_2=1$이다. 즉 step 번호는 인덱스이고, 실제 물리량은 $\sigma_k$다.</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>get_sigmas_*</code> 함수들이 $S$를 구현한다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>solver만 바꾸고 스케줄을 고정하면 기대한 차수/안정성 향상이 안 나올 수 있다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="Sigma.html">$\Sigma$</a><a class="btn" href="Phi_k.html">$\Phi_k$</a></div><div class="topnav"><a class="btn" href="TxM.html">이전: $T_x\mathcal{M}$</a><a class="btn" href="D_theta.html">다음: $D_\theta$</a></div></article></div></body></html>