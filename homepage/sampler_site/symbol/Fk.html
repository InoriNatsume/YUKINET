<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Fk</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $\mathcal{F}_k$</h1><p class='muted'><strong>자연 필트레이션 (Natural filtration)</strong></p><h2>모티베이션 (Motivation)</h2><p>$\mathcal{F}_k$는 ‘$k$번째 step 직전까지 어떤 난수들을 이미 봤는가’를 나타내는 정보 집합(필트레이션)이다. “미래 난수를 미리 보지 않는다”를 엄밀히 쓰면 $\mathcal{F}_k$-가측성으로 표현된다.</p><ol class='list'><li>확률 과정에서 ‘현재까지의 정보로만 다음을 계산한다’는 말(적응성, adaptedness)을 수식으로 쓰려면, 시간에 따라 정보가 늘어나는 구조 $\{\mathcal{F}_k\}$가 필요하다. 샘플러 루프가 온라인 알고리즘이라는 사실을 엄밀히 기록하는 장치다.</li><li>ComfyUI에서 seed 재현성이 깨지는 흔한 이유 중 하나가 “중간에 RNG를 한 번 더(혹은 덜) 소비하는 부수 작업”이다(예: 디버그 출력, preview, 조건 분기). 이런 변화는 결국 $\xi_k$의 소비 순서를 바꾸고, 그 결과 $\mathcal{F}_k$ 관점에서 ‘무엇이 언제 알려졌는가’가 달라진다.</li><li>look-ahead(미래 난수 참조) 같은 버그/변형이 있으면 $\mathcal{F}_k$-적응성이 깨지고, SDE 해석(독립 증분 가정, 오차 분석)이 달라질 수 있다. 특히 adaptive step-size(accept/reject) 같은 로직을 넣을 때 이 문제가 더 쉽게 발생한다.</li><li>deterministic sampler에서는 난수 유입이 거의 없어서 필트레이션이 사실상 단순해지지만, ancestral/SDE에서는 매 step 새 난수 증분이 들어가므로 $\mathcal{F}_k$ 구조가 의미를 갖는다. “이 sampler는 어디에서 랜덤성을 쓰는가”를 체계적으로 설명할 때 도움이 된다.</li><li>영상/병렬 샘플링에서는 프레임/타일마다 RNG를 어떤 순서로 소비할지 규약이 필요하다. 이를 ‘정보의 시간 순서’로 보고 $\mathcal{F}_k$를 의식하면, 구현이 바뀌어도 재현성 규약을 유지하는 설계를 하기가 쉬워진다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{F}_k=\sigma(\xi_0,\dots,\xi_{k-1}) $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ x_k\ \text{is }\mathcal{F}_k\text{-measurable} $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 “$k$번째 step까지 어떤 난수들이 공개됐는가”를 $\sigma$-대수로 포장한다. $k$가 커질수록 더 많은 난수를 보니 정보가 늘어나고, 그래서 보통 $\mathcal{F}_0\subseteq\mathcal{F}_1\subseteq\cdots$가 된다.</p><p>둘째 문장은 적응성(adaptedness)의 정의다. $x_k$가 $\mathcal{F}_k$-가측이라는 것은 $x_k$가 $\xi_0,\dots,\xi_{k-1}$만으로 결정된다는 뜻이며, 미래 난수 $\xi_k,\xi_{k+1},\dots$를 참조하지 않는다는 의미다.</p><p>이 문법을 써두면 $\Phi_k$의 비예견성 조건을 엄밀히 쓸 수 있고, SDE의 strong/weak error 논의 같은 이론으로 자연스럽게 연결된다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{F}_k=\sigma(\xi_0,\dots,\xi_{k-1}) $$</div><h3>해설</h3><ol class='list'><li>$\sigma(\xi_0,\dots,\xi_{k-1})$는 “이 난수들로 결정되는 모든 사건”의 모음이다. 즉 $\xi_0,\dots,\xi_{k-1}$를 알면 판정할 수 있는 질문들의 집합이다.</li><li>$k$가 증가하면 더 많은 난수를 포함하므로 정보가 늘어난다: $\mathcal{F}_k\subseteq\mathcal{F}_{k+1}$.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>“지금까지 나온 난수 로그”가 커질수록, 할 수 있는 판단(사건)이 많아진다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\xi_0=0.5$를 이미 봤다면, 사건 “$\xi_0&gt;0$”는 $\mathcal{F}_1$에 속한다.</li><li>$k=2$면 $\xi_0,\xi_1$을 보았으니, 사건 “$\xi_0+\xi_1&gt;0$”도 $\mathcal{F}_2$에 속한다.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ x_k\ \text{is }\mathcal{F}_k\text{-measurable} $$</div><h3>해설</h3><ol class='list'><li>이는 $x_k$가 과거 정보만으로 계산된다는 뜻이다. 즉 $x_k=f(\xi_0,\dots,\xi_{k-1})$ 꼴로 쓸 수 있다는 직관과 맞닿아 있다.</li><li>샘플러가 미래 노이즈를 미리 뽑아서 섞어 쓰면 이 조건이 깨질 수 있다(look-ahead).</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>“미래를 보지 않는” 정상적인 온라인 알고리즘이라는 의미다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$x_1=x_0+\alpha\xi_0$라면 $x_1$은 $\xi_0$만으로 결정되므로 $\mathcal{F}_1$-가측이다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>‘지금까지 공개된 난수와 계산 결과를 모두 모아 둔 장부’라고 보면 된다.</li><li>$k$가 커질수록 더 많은 난수를 봤으니 $\mathcal{F}_k\subseteq\mathcal{F}_{k+1}$로 정보가 늘어난다.</li><li>“미래 난수를 미리 보지 않는다(no peeking)”를 엄밀히 쓰면 $x_k$가 $\mathcal{F}_k$-가측이라는 말이 된다. 즉 샘플러는 현재까지 생성된 난수에만 의존해야 한다(확률과정의 적응성/adaptedness).</li><li>코드 구현에서 난수를 ‘미리 한 번에 뽑아 배열로 저장’해도 된다. 그 경우에도 $k$번째 업데이트가 그 배열의 앞부분(0..k-1)만 참조하도록 만들면 $\mathcal{F}_k$-적응성을 만족한다(필트레이션을 구현으로 옮긴 것).</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>예를 들어 $\xi_0=0.5$, $\xi_1=-1.2$가 뽑혔다면 $k=2$ 시점의 정보는 “$\xi_0=0.5$와 $\xi_1=-1.2$를 이미 봤다”를 포함한다.</li><li>$x_2$가 $\mathcal{F}_2$-가측이라는 말은 $x_2$가 $\xi_0,\xi_1$만으로 계산되고, $\xi_2$ 이후 값은 보지 않았다는 뜻이다.</li><li>(수치 예) $\Omega=\mathbb{R}^2$에 좌표 $(\xi_0,\xi_1)$를 두고 $\mathcal{F}_1=\sigma(\xi_0)$라 하자. 사건 $A=\{\xi_0&gt;0\}$는 $\mathcal{F}_1$에 속하지만, $B=\{\xi_1&gt;0\}$는 $\mathcal{F}_1$에 속하지 않는다(미래 성분).</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li>루프에서 매 step 새 난수를 뽑아 즉시 쓰는 구조가 필트레이션 적응성과 대응된다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>미래 노이즈를 재사용하는 look-ahead 구현은 확률모형 가정을 위반할 수 있다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="Xi_k.html">$\xi_k$</a><a class="btn" href="Phi_k.html">$\Phi_k$</a><a class="btn" href="Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><div class="topnav"><a class="btn" href="Xi_k.html">이전: $\xi_k$</a><a class="btn" href="Rho_t.html">다음: $\rho_t$</a></div></article></div></body></html>