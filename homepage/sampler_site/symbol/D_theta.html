<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: D_theta</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $D_\theta$</h1><p class='muted'><strong>모형 사상 (Model map: denoiser/score)</strong></p><h2>모티베이션 (Motivation)</h2><p>신경망(예: U-Net)이 구현하는 함수다. 현재 상태 $x$, 노이즈 수준 $\sigma$, 조건 $c$를 넣으면 같은 차원의 벡터(또는 ‘denoised’ 추정치)를 반환한다. 샘플러는 이 함수를 step마다 여러 번 호출해서 업데이트 방향을 만든다.</p><ol class='list'><li>ComfyUI에서 sampler는 본질적으로 <code>model(x, sigma, cond)</code>를 여러 번 호출하는 루프다. <code>model</code> 객체 안에는 U-Net뿐 아니라 CFG/컨트롤/LoRA/추가 모듈이 래핑되어 들어갈 수 있지만, 외부에서 보면 결국 하나의 함수 $D_\theta$로 행동한다. 이 관점을 잡아야 “샘플러를 바꾼다”와 “모델을 바꾼다”를 분리해서 사고할 수 있다.</li><li>Euler/Heun/DPM++/LMS 등 다양한 sampler는 수식은 달라도, 대부분 ‘한 step에서 $D_\theta$를 몇 번 평가하고 어떻게 조합하느냐’로 요약된다. 그래서 같은 <code>steps</code>라도 sampler마다 속도(모델 호출 수)와 품질(근사 차수)이 달라진다. $D_\theta$를 중심에 두면 이 차이가 명확해진다.</li><li>실무에서 가장 흔한 버그는 ‘모델 출력의 의미’를 잘못 해석하는 것이다. 어떤 모델은 $\epsilon$을, 어떤 모델은 $x_0$를, 어떤 모델은 $v$를 예측한다. ComfyUI는 내부에서 이런 파라미터화를 맞추는 래퍼를 두지만, 커스터마이징(자체 샘플러/모델 래핑)을 하려면 $D_\theta$가 무엇을 반환한다고 가정하는지부터 고정해야 한다.</li><li>CFG는 $D_\theta(x,\sigma,c)$와 $D_\theta(x,\sigma,c_{\emptyset})$를 둘 다 평가한 뒤 <code>cfg</code> 스케일로 섞는다. 즉 한 step의 비용과 동작이 조건 설계에 직접 의존한다. 프롬프트/컨트롤을 복잡하게 만들수록 ‘한 번의 $D_\theta$ 호출이 의미하는 것’이 중요해지고, 타입/입력 구조를 명확히 해 두면 디버깅이 쉬워진다.</li><li>커스텀 sampler를 만들 때는 $D_\theta$ 출력으로부터 drift/score/velocity 등을 계산해 적분한다. 이 과정에서 필요한 것은 “입력 $(x,\sigma,c)$에 대해 출력이 어떤 공간의 원소인가”라는 타입과, “출력 물리량이 무엇인가”라는 해석이다. 둘 다 $D_\theta$ 정의에 포함된다.</li><li>영상/조건 스케줄링에서는 step 또는 프레임에 따라 조건을 바꾸는 경우가 많다. 이때도 sampler 본체는 그대로 두고 $c$만 바꾸면 되도록 인터페이스를 설계하는 게 보통 유리하다. 결국 $D_\theta$를 ‘조건을 포함한 함수’로 보는 관점이 이런 확장을 가능하게 한다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ D_\theta:\mathcal{X}\times\Sigma\times\mathcal{C}\to\mathcal{X} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \hat{x}_0=D_\theta(x,\sigma,c)\quad(\text{one possible parameterization}) $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 $D_\theta$가 ‘입력 3개를 받아 출력 1개를 내는 함수’라는 타입 선언이다. 이 타입이 맞으면 sampler가 어떤 식으로 조합하더라도 최소한 계산이 성립한다.</p><p>둘째 문장은 수치해석적 안전장치다. solver는 $D_\theta$를 여러 점에서 평가해 선형 결합을 만들기 때문에, $D_\theta$가 너무 요동치면(비연속/폭주) step이 불안정해진다. 그래서 보통 국소 Lipschitz 같은 가정을 깔고 논의를 시작한다.</p><p>셋째 문장은 실무에서 가장 자주 터지는 함정이다. 어떤 코드는 $D_\theta$가 $x_0$를 예측한다고 가정하고, 어떤 코드는 $\epsilon$을 예측한다고 가정한다. 같은 네트워크 출력이라도 ‘어떤 물리량으로 해석하느냐’가 달라지면 업데이트 식의 계수/스케일이 달라진다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ D_\theta:\mathcal{X}\times\Sigma\times\mathcal{C}\to\mathcal{X} $$</div><h3>해설</h3><ol class='list'><li>입력 $(x,\sigma,c)$에서 $x\in\mathcal{X}$는 현재 상태, $\sigma\in\Sigma$는 노이즈 수준, $c\in\mathcal{C}$는 조건이다.</li><li>출력은 다시 $\mathcal{X}$의 원소다. 즉 상태와 같은 차원의 벡터가 나온다(예: denoised 추정치나 score/velocity).</li><li>샘플러는 이 출력을 그대로 쓰지 않고, 보통 ‘방향 벡터’로 변환(to\_d 등)한 뒤 적분한다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>모델 호출 한 번은 “지금 위치에서 나침반을 한 번 읽는다”에 가깝다. 2-stage solver는 중간 위치에서도 한 번 더 읽는다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\mathcal{X}=\mathbb{R}^2$에서 $D_\theta((0.5,-1.2),1.0,(1.5,-0.3))=(0.42,-1.05)$ 같은 출력이 나올 수 있다.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \hat{x}_0=D_\theta(x,\sigma,c)\quad(\text{one possible parameterization}) $$</div><h3>해설</h3><ol class='list'><li>$D_\theta$가 ‘깨끗한 샘플 $\hat{x}_0$’를 직접 예측한다고 해석하는 경우가 많다. 이때 샘플러는 $x$와 $\hat{x}_0$의 차이를 이용해 drift를 만든다.</li><li>반대로 $\epsilon$-pred, v-pred에서는 $D_\theta$ 출력이 다른 물리량이므로, $\hat{x}_0$나 score로 바꾸는 변환이 필요하다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>“모델이 무엇을 출력한다고 가정했는가”가 solver 식의 계수를 결정한다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$x=(0.5,-1.2)$, $\hat{x}_0=(0.42,-1.05)$이면 차이는 $\hat{x}_0-x=(-0.08,0.15)$이다. 많은 업데이트 식은 이 차이를 스케일링해서 이동량으로 쓴다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>$D_\theta$는 ‘지금 상태가 너무 노이즈가 섞여 있는데, 깨끗한 쪽이 어디인지’ 힌트를 주는 함수라고 보면 된다.</li><li>반환값 자체가 곧바로 다음 $x$가 되는 것이 아니라, 보통은 그 반환값으로부터 drift/방향 벡터를 만들어 한 step 이동한다.</li><li>ComfyUI에서 sampler는 매 step마다 같은 형태로 $D_\theta$를 호출한다. 그래서 “sampler의 차이”는 대부분 (1) $D_\theta$를 몇 번 평가하는지, (2) 그 평가값을 어떻게 조합하는지의 차이다(수치해석 관점의 적분기 선택).</li><li>모델 파라미터화(parameterization)가 달라도 샘플러가 일관되게 동작하려면, 내부에서 출력 의미를 맞추는 변환이 필요하다. 예를 들어 $\epsilon$-예측이면 $\hat{x}_0=x-\sigma\hat\epsilon$로 바꿔 denoised를 만들 수 있고, $v$-예측도 적절한 선형변환으로 환산한다.</li><li>코드 구현에서 가장 중요한 불변식은 “입력과 출력 텐서의 shape가 같다”는 점이다. 즉 <code>model(x, sigma, cond)</code>는 보통 <code>x</code>와 같은 shape의 텐서를 반환해야 샘플러 업데이트가 닫힌다(closure).</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>(숫자는 예시) $\mathcal{X}=\mathbb{R}^2$라 하고 $x=(0.5,-1.2)$, $\sigma=1.0$, $c=(1.5,-0.3)$를 넣었더니 $D_\theta(x,\sigma,c)=(0.42,-1.05)$ 같은 벡터가 나온다고 하자. 출력도 $\mathbb{R}^2$의 원소다.</li><li>또 다른 호출에서 $x=(1.0,0.0)$, $\sigma=5.0$, $c=(0.0,1.0)$일 때 $D_\theta(x,\sigma,c)=(0.2,-0.1)$처럼 전혀 다른 값이 나올 수 있다(조건/노이즈에 따라 달라짐).</li><li>($\epsilon$-예측 수치 예) 모델이 $\hat\epsilon$을 예측한다고 하자. $x=(1.0,-0.5)$, $\sigma=2.0$, $\hat\epsilon=(0.3,-0.1)$이면 denoised 추정치는 $\hat{x}_0=x-\sigma\hat\epsilon=(1.0,-0.5)-2.0(0.3,-0.1)=(0.4,-0.3)$이다.</li><li>(shape 예) <code>x.shape=(1,4,64,64)</code>인 latent를 넣으면 $D_\theta$의 출력도 보통 같은 <code>shape=(1,4,64,64)</code>다. 예를 들어 어떤 위치의 성분이 $x[0,0,0,0]=0.12$였다면 출력도 같은 인덱스에 실수 값을 준다(예: 0.08).</li><li>(CFG 연산 예) $D_\theta(x,\sigma,c)=(1,2)$, $D_\theta(x,\sigma,c_\emptyset)=(0.2,1.5)$, <code>cfg=2</code>면 guided 출력은 $(0.2,1.5)+2((1,2)-(0.2,1.5))=(1.8,2.5)$다(조건 차이를 적당히 증폭).</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>model(x, sigma, cond)</code> 호출 결과가 직접 drift/보정항 계산에 들어간다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>파라미터화($\epsilon$-pred, $x_0$-pred, v-pred) 차이를 무시하면 업데이트 식이 달라진다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="X.html">$\mathcal{X}$</a><a class="btn" href="Sigma.html">$\Sigma$</a><a class="btn" href="C_G.html">$(\mathcal{C},\mathcal{G})$</a><a class="btn" href="b_theta.html">$b_\theta$</a></div><div class="topnav"><a class="btn" href="S_map.html">이전: $S$</a><a class="btn" href="b_theta.html">다음: $b_\theta$</a></div></article></div></body></html>