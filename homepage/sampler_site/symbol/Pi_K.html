<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Pi_K</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $\Pi_{\mathcal{K}}$</h1><p class='muted'><strong>집합 투영 연산자 (Projection operator)</strong></p><h2>모티베이션 (Motivation)</h2><p>임의의 점 $x\in\mathcal{X}$를 허용 집합 $\mathcal{K}$ 안으로 되돌리는 연산을 $\Pi_{\mathcal{K}}$로 적는다. ‘제약을 만족시키는 보정 단계’를 수학적으로 한 글자로 표기한 것이다.</p><ol class='list'><li>ComfyUI의 편집 파이프라인은 종종 ‘샘플러 업데이트 후 보정’을 끼워 넣는다(마스크 고정, latent 합성, clamp 등). 이를 수학적으로는 $x\leftarrow \Pi_{\mathcal{K}}(x)$ 한 줄로 쓰며, 전체 알고리즘은 $\Phi_k$와 $\Pi_{\mathcal{K}}$의 합성으로 정리된다. 이 관점이 있어야 “제약이 언제/어디서 적용되는가”가 명확해진다.</li><li>같은 제약이라도 ‘어떤 거리(노름)’에 대한 투영인지에 따라 결과가 달라질 수 있다. 예를 들어 유클리드 노름에서는 좌표별 clip이 자연스럽지만, 채널별 가중치를 주면(가중 노름) 어떤 채널을 더 강하게 보정하는 투영이 된다. $\Pi_{\mathcal{K}}$ 표기는 이런 전제(거리 구조)를 드러낸다.</li><li>inpaint를 ‘허용집합으로의 투영’으로 보면, hard mask는 정확한 투영이고 soft mask는 투영의 완화(또는 proximal/relaxation)로 이해할 수 있다. 그래서 경계(seam) 문제를 줄이기 위해 마스크를 블러 처리하는 실무 팁도 “투영을 부드럽게 만든다”로 해석된다.</li><li>수치해석/최적화에서는 projected Euler, projected gradient descent, proximal point 같은 기법이 표준이다. 샘플러에 투영을 끼워 넣는 아이디어는 이런 계열과 구조적으로 같아서, 안정성(발산 방지)과 제약 만족을 동시에 얻는 이유를 설명해 준다.</li><li>커스텀 샘플러를 만들 때도 $\Pi_{\mathcal{K}}$를 명시적으로 분리해 두면, ‘기본 샘플러’는 그대로 두고 제약만 교체/추가하는 모듈식 설계가 가능해진다(예: 같은 sampler에 다른 inpaint 제약을 끼워 넣기).</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Pi_{\mathcal{K}}:\mathcal{X}\to\mathcal{K} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \Pi_{\mathcal{K}}(x)=\arg\min_{y\in\mathcal{K}}\|x-y\|_2 $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 “투영은 언제나 $\mathcal{K}$ 안의 점을 반환한다”는 뜻이다. 즉, 보정 후에는 제약을 만족한다($\Pi_{\mathcal{K}}(x)\in\mathcal{K}$).</p><p>둘째 문장은 투영을 ‘최소거리 문제’로 정의한다. 여기서 거리의 기준이 $\|\cdot\|_2$이므로, 다른 노름(가중 노름 등)을 쓰면 투영 연산도 달라진다.</p><p>볼록성은 유일성을 보장하는 전형적인 조건이다. 비볼록이면 최소점이 여러 개일 수 있어서, 구현이 어떤 점을 고르는지(타이브레이크 규칙)가 결과에 영향을 준다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Pi_{\mathcal{K}}:\mathcal{X}\to\mathcal{K} $$</div><h3>해설</h3><ol class='list'><li>입력은 임의의 상태 $x\in\mathcal{X}$이고, 출력은 제약을 만족하는 상태 $\Pi_{\mathcal{K}}(x)\in\mathcal{K}$다.</li><li>따라서 “solver가 만든 후보 $x$를 제약 안으로 되돌린다”를 함수 합성으로 $x\leftarrow \Pi_{\mathcal{K}}(x)$처럼 쓸 수 있다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>항상 제약을 만족하는 ‘정정 단계’다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\mathcal{K}=[-1,1]$에서 $x=2.3$이면 $\Pi_{\mathcal{K}}(x)=1.0$.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \Pi_{\mathcal{K}}(x)=\arg\min_{y\in\mathcal{K}}\|x-y\|_2 $$</div><h3>해설</h3><ol class='list'><li>투영은 최소화 문제로 정의된다. 목적함수는 “$x$와 $y$의 거리”다.</li><li>볼록이면 유일성이 확보되는 경우가 많고, 수치 구현도 명확해진다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>상자 제약이면 ‘좌표별로 잘라내기’가 최소거리 투영과 일치한다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\mathcal{K}=[-1,1]^2$, $x=(1.4,-0.5)$이면 가장 가까운 점은 $(1.0,-0.5)$.</li><li>$\mathcal{K}=\{(0.2,y_2,y_3)\}$, $x=(0.9,-1.0,0.1)$이면 첫 좌표만 바뀐 $(0.2,-1.0,0.1)$이 가장 가깝다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>규칙 위반한 점을 가장 가까운 합법 점으로 ‘스냅(snap)’시키는 연산이다.</li><li>$\mathcal{K}$가 ‘상자(box)’면 clip, ‘좌표 고정’이면 해당 좌표를 덮어쓰는 동작으로 생각하면 된다.</li><li>ComfyUI의 inpaint는 마스크로 고정할 좌표를 정한 뒤, 매 step에서 그 좌표를 다시 원본으로 덮어쓰는 형태가 흔하다. 이것이 바로 “아핀 부분공간으로의 투영”의 구현이다.</li><li>코드 구현에서는 $\Pi_{\mathcal{K}}$가 너무 비싸면(복잡한 제약) soft constraint(패널티/프로시멀)로 바꾸기도 한다. 하지만 ‘하드 제약이면 투영’이라는 원칙을 알면 커스터마이징 선택지가 명확해진다.</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>$\mathcal{X}=\mathbb{R}^2$, $\mathcal{K}=[-1,1]^2$, $x=(1.4,-0.5)$이면 $\Pi_{\mathcal{K}}(x)=(1.0,-0.5)$.</li><li>$\mathcal{X}=\mathbb{R}^3$, $\mathcal{K}=\{(0.2,y_2,y_3)\}$, $x=(0.9,-1.0,0.1)$이면 $\Pi_{\mathcal{K}}(x)=(0.2,-1.0,0.1)$.</li><li>(clip 수치 예) $d=2$, $\mathcal{K}=[-1,1]^2$, $x=(1.3,-1.4)$면 $\Pi_{\mathcal{K}}(x)=(1.0,-1.0)$이다.</li><li>(마스크 수치 예) $x=(0.1,0.2,0.3,0.4)$, $x_{\mathrm{fix}}=(1,1,0,0)$, $m=(1,1,0,0)$이면 $\Pi_{\mathcal{K}}(x)=m\odot x_{\mathrm{fix}}+(1-m)\odot x=(1,1,0.3,0.4)$로 계산된다.</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>torch.clamp</code>, 마스크 기반 overwrite가 대표적인 구현이다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>비유클리드 거리/가중 노름을 쓰면 projection 공식이 달라진다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="K_set.html">$\mathcal{K}$</a><a class="btn" href="X.html">$\mathcal{X}$</a></div><div class="topnav"><a class="btn" href="Psi_k.html">이전: $\Psi_k$</a><a class="btn" href="R_x.html">다음: $R_x$</a></div></article></div></body></html>