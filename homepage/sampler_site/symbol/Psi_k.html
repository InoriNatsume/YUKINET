<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Psi_k</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $\Psi_k$</h1><p class='muted'><strong>과거값 갱신 사상 (History update map)</strong></p><h2>모티베이션 (Motivation)</h2><p>multistep 샘플러는 과거값/과거 기울기 등을 버퍼에 저장한다. $\Psi_k$는 ‘새로운 상태 $x_{k+1}$를 얻은 뒤 그 버퍼를 어떻게 갱신하는가’를 나타내는 함수다.</p><ol class='list'><li>multistep sampler의 성능/정확도는 ‘과거 정보를 어떻게 들고 가는가’에 크게 좌우된다. 즉 solver 공식을 정확히 구현하려면, 버퍼의 내용뿐 아니라 갱신 규칙까지 명확해야 한다. $\Psi_k$는 그 갱신 규칙을 solver 본체에서 분리해 이름 붙인 것이다.</li><li>ComfyUI에서 <code>lms</code>, <code>dpmpp_2m</code>, <code>deis</code>, <code>ipndm</code> 같은 계열은 내부적으로 과거 denoised/derivative를 저장한다. 이때 버퍼를 shift하는 순서가 바뀌거나, 한 step 늦게/빠르게 넣으면 같은 이름의 sampler라도 완전히 다른 수치식을 실행하게 된다. $\Psi_k$를 명시하면 이런 실수를 문서/코드에서 바로 드러낼 수 있다.</li><li>초기 워밍업 구간에서는 과거가 부족해서 버퍼 길이 $m_k$가 커져 가는 경우가 많다. 이때 갱신은 단순 ‘한 칸 밀고 넣기’가 아니라 ‘길이를 늘리기 + 밀기’가 섞인다. $\Psi_k$에 이 규칙을 포함시키면 워밍업을 포함한 전체 알고리즘이 한 틀로 정리된다.</li><li>실무적으로는 ‘중간 상태 저장/재개’에서 $\Psi_k$가 결정적이다. $x_k$만 저장해 재개하면 multistep 버퍼가 초기화되어, 이어서 돌리는 구간이 사실상 저차 방법으로 바뀐다. 버퍼(= $h_k$)와 그 갱신 규약까지 함께 저장해야 동일한 궤적을 재현할 수 있다.</li><li>영상 생성/타일링처럼 여러 스트림을 병렬로 샘플링할 때도, 버퍼를 어느 단위로 유지할지(프레임별/타일별 독립) 설계해야 한다. 이는 결국 $\Psi_k$를 ‘어떤 상태 증강 공간’에서 정의할지의 문제로 귀결된다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \text{warmup: }m_k\ \text{can increase with }k $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>이 타입 선언은 “버퍼 $h_k$와 새 상태 $x_{k+1}$를 받아서 다음 버퍼 $h_{k+1}$를 만든다”는 뜻이다.</p><p>다단계 solver를 구현할 때 자주 실수하는 지점이 버퍼의 순서/길이다. $\Psi_k$를 따로 떼어 생각하면 “버퍼 갱신 로직”이 solver 본체와 분리돼 검증하기 쉬워진다.</p><p>워밍업 구간에서는 $m_k$가 작다가 점점 최대 차수로 올라가는 경우가 많다. 이때 $\Psi_k$는 단순 shift뿐 아니라 “길이를 늘리는 규칙”까지 포함할 수 있다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Psi_k:(\mathcal{H}_k\times\mathcal{X})\to\mathcal{H}_{k+1} $$</div><h3>해설</h3><ol class='list'><li>입력은 (현재 버퍼 $h_k$, 새 상태 $x_{k+1}$)이고 출력은 다음 버퍼 $h_{k+1}$이다.</li><li>$\mathcal{H}_k$ 자체가 $\mathcal{X}^{m_k}$ 형태이므로, 결국 $\Psi_k$는 “튜플을 어떻게 업데이트하나”의 문제로 내려온다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>코드에서는 보통 <code>append</code>/<code>pop(0)</code> 또는 <code>deque</code>의 <code>append</code>/<code>popleft</code> 조합으로 구현된다.</li></ol><h3>수치 예시</h3><ol class='list'><li>2-step에서 $h_k=(x_{k-1},x_k)$이면 $\Psi_k(h_k,x_{k+1})=(x_k,x_{k+1})$.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \text{warmup: }m_k\ \text{can increase with }k $$</div><h3>해설</h3><ol class='list'><li>초기에는 과거값이 부족하므로 $m_0=0$ 또는 $m_0=1$에서 시작해 $m_k$를 점차 늘리는 구현이 흔하다.</li><li>예를 들어 목표가 3-step solver이면, $k=0$에서는 1-step처럼 돌리고, $k=1$부터 2-step, $k=2$부터 3-step으로 전환하는 식이다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>‘기억이 쌓여야 고차 방법을 쓸 수 있다’는 뜻이다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$m_0=0$ (버퍼 없음) → $m_1=1$ (최근 1개 저장) → $m_2=2$ (최근 2개 저장)처럼 늘어날 수 있다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>리스트/큐를 한 칸 민 뒤, 맨 뒤에 새 값을 넣는 연산이라고 보면 된다.</li><li>무엇을 저장하느냐(상태 $x$인지, denoised인지, derivative인지)에 따라 $\mathcal{H}_k$의 내용만 바뀌고 ‘갱신’이라는 구조는 같다.</li><li>코드에서는 보통 <code>append</code> 후 <code>pop(0)</code>(또는 <code>deque(maxlen=m)</code>)로 구현되는 간단한 연산이지만, 이 한 줄이 solver 차수/안정성에 직접 영향을 준다. 예를 들어 무엇을 저장하느냐(x, denoised, residual)가 달라지면 완전히 다른 multistep이 된다.</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>$\mathcal{X}=\mathbb{R}^2$, 2-step 버퍼라 하자. $h_k=((1.0,0.0),(0.3,-0.2))$, $x_{k+1}=(0.1,0.0)$이면 $\Psi_k(h_k,x_{k+1})=((0.3,-0.2),(0.1,0.0))$.</li><li>1-step(버퍼 없음)으로 보면 $\mathcal{H}_k$가 한 점 공간이므로, 사실상 $\Psi_k$는 ‘아무 것도 안 함’에 가깝다.</li><li>(리스트 구현 예) history 길이를 2로 유지한다고 하자. <code>history=[0.20, 0.12]</code>이고 새 값이 0.05면, 갱신 후 <code>history=[0.12, 0.05]</code>가 된다(가장 오래된 값 제거).</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>old_denoised.append(...)</code>, <code>pop(0)</code> 같은 로직이 $\Psi_k$에 해당한다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>버퍼 순서를 바꾸면 같은 solver 이름이라도 실제 수치식이 달라진다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="Hk_Ak.html">$(\mathcal{H}_k,\mathcal{A}_k)$</a><a class="btn" href="Phi_k.html">$\Phi_k$</a></div><div class="topnav"><a class="btn" href="Phi_k.html">이전: $\Phi_k$</a><a class="btn" href="Pi_K.html">다음: $\Pi_{\mathcal{K}}$</a></div></article></div></body></html>