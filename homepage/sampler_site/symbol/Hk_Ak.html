<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Hk_Ak</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $(\mathcal{H}_k,\mathcal{A}_k)$</h1><p class='muted'><strong>다단계 과거값 곱공간 (Multi-step history product space)</strong></p><h2>모티베이션 (Motivation)</h2><p>다단계(multistep) 샘플러는 현재 상태 $x_k$만으로 다음 값을 만들지 않고, 과거 값들을 ‘버퍼’로 들고 다닌다. 그 버퍼가 사는 공간을 $\mathcal{H}_k$로 적는다.</p><ol class='list'><li>ComfyUI에서 <code>sampler_name</code>으로 고르는 것들 중 상당수(<code>lms</code>, <code>dpmpp_2m</code>, <code>dpmpp_3m_sde</code>, <code>deis</code>, <code>ipndm</code> 등)는 multistep 계열이다. 이런 방법은 $x_k$만으로 $x_{k+1}$를 만들지 않고, 이전 step들의 상태/모델출력(=과거 정보)을 함께 섞어 업데이트한다. 그 ‘과거 정보가 들어 있는 버퍼’의 수학적 타입이 $\mathcal{H}_k$다.</li><li>multistep의 핵심은 같은 모델 호출 수에서 더 높은 차수(더 작은 적분 오차)를 얻는 것이다. 대신 과거가 없으면 고차 공식을 쓸 수 없어서, 초기 몇 step은 저차로 시작하는 워밍업이 반드시 생긴다. $\mathcal{H}_k=\mathcal{X}^{m_k}$처럼 쓰면 이 워밍업(버퍼 길이 $m_k$ 증가)을 깔끔하게 한 틀로 설명할 수 있다.</li><li>생성/편집 파이프라인에서 “중간에 멈췄다가 이어서 샘플링”하거나 “일부 step만 추가로 더 돌리기” 같은 요구가 자주 생긴다. 이때 과거 버퍼를 함께 저장/복원하지 않으면, 이어서 돌리는 부분이 사실상 다른 solver(저차)로 바뀌어 결과가 미묘하게 달라질 수 있다. 재현성과 커스터마이징 관점에서 $\mathcal{H}_k$는 실무적으로도 중요하다.</li><li>영상 생성처럼 여러 프레임을 다룰 때는 ‘프레임별로’ history를 어떻게 유지할지(프레임마다 독립인지, 공유/상관을 줄지)를 결정해야 한다. 수학적으로는 “상태공간을 확장하거나(시간축 포함)”, “history의 정의를 프레임 단위로 분리”하는 문제이며, 이를 명확히 쓰는 기호가 $\mathcal{H}_k$다.</li><li>커스텀 solver를 만들 때도 “무엇을 과거로 저장하나”가 설계의 절반이다. 과거 $x$를 저장할 수도 있고, 과거 모델 출력(denoised/score)이나 잔차(residual)를 저장할 수도 있다. $\mathcal{H}_k$를 명시하면 이런 설계 차이를 타입 수준에서 비교할 수 있다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{H}_k=\mathcal{X}^{m_k} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \mathcal{A}_k=\mathcal{B}(\mathcal{X})^{\otimes m_k} $$</div></div><div class='box'><p class='small'><strong>정의 3.</strong></p><div class='formula'>$$ m_k=0 \Rightarrow \mathcal{H}_k \simeq \{\ast\} $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 “버퍼가 $m_k$개의 상태를 담는 튜플”이라는 뜻이다. 예를 들어 2-step이면 $h_k=(x_{k-1},x_k)$처럼 두 개를 들고 다닌다.</p><p>여기서 $\mathcal{A}_k$를 같이 적는 이유는, 확률론적으로 ‘버퍼도 확률변수’일 수 있기 때문이다. 하지만 대부분의 실무 독해에서는 $\mathcal{H}_k=\mathcal{X}^{m_k}$만 기억해도 충분하다.</p><p>두 번째 문장($m_k=0$)은 “과거가 아직 없는 초기 step도 같은 수식 틀 안에 넣겠다”는 장치다. 즉, 1-step 방법과 multistep 방법을 한 문장으로 쓰기 위한 통일 표기다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \mathcal{H}_k=\mathcal{X}^{m_k} $$</div><h3>해설</h3><ol class='list'><li>$\mathcal{X}$는 상태가 사는 공간(예: $\mathbb{R}^d$)이고, $\mathcal{X}^{m_k}$는 그 공간의 원소 $m_k$개를 한꺼번에 묶은 튜플들의 집합이다.</li><li>즉 $h_k\in\mathcal{H}_k$는 “과거 상태들을 모아 둔 묶음”이며, multistep solver가 내부적으로 들고 다니는 메모리의 수학적 모델이다.</li><li>$m_k$가 커질수록 더 많은 과거 정보를 사용할 수 있어, 같은 step 수에서도 더 고차의 근사식을 만들 수 있다(대신 초기 워밍업이 필요).</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>코드에서 <code>history=[x_{k-1}, x_k]</code>처럼 리스트로 저장하는 것과 1:1로 대응된다.</li><li>이 정의를 써두면 “업데이트는 $(x_k,h_k)$의 함수다”처럼 깔끔하게 말할 수 있다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\mathcal{X}=\mathbb{R}^2$, $m_k=2$라 두자. 그러면 $\mathcal{H}_k=\mathbb{R}^2\times\mathbb{R}^2$이고, $h_k=((1.0,0.0),(0.3,-0.2))\in\mathcal{H}_k$.</li><li>$m_k=3$이면 $h_k=((1.0,0.0),(0.3,-0.2),(0.1,0.0))$처럼 3개를 들고 다닌다.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \mathcal{A}_k=\mathcal{B}(\mathcal{X})^{\otimes m_k} $$</div><h3>해설</h3><ol class='list'><li>확률론을 엄밀히 쓰려면 “$h_k$가 어떤 사건들에 대해 가측인가”를 정해야 한다. $\mathcal{A}_k$는 그 사건들의 표준 선택이다(product $\sigma$-대수).</li><li>실무적으로는 ‘버퍼도 $\mathcal{X}$값 확률변수들의 튜플’이라고 이해하면 되고, 측도론이 필요 없는 독해에서는 이 줄을 생략해도 무방하다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>이 줄은 수치적 구현을 바꾸지 않는다. 다만 “확률변수/분포/기대값”을 논문 스타일로 쓸 때 문법을 맞춰 준다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$\mathcal{X}=\mathbb{R}$, $m_k=2$면 $\mathcal{A}_k=\mathcal{B}(\mathbb{R})\otimes\mathcal{B}(\mathbb{R})$이다. 예를 들어 집합 $(-1,2)\times[0,1]$은 $\mathcal{A}_k$에 속한다.</li></ol></div><div class='box'><p class='small'><strong>정의 3.</strong></p><div class='formula'>$$ m_k=0 \Rightarrow \mathcal{H}_k \simeq \{\ast\} $$</div><h3>해설</h3><ol class='list'><li>초기에는 과거값이 없으므로 “버퍼가 비어 있다”는 상황이 생긴다. 이를 수학적으로는 ‘한 점만 있는 집합’ $\{\ast\}$로 모델링한다.</li><li>이렇게 하면 $\Phi_k:\mathcal{X}\times\mathcal{H}_k\to\mathcal{X}$ 같은 전이 사상을 1-step/다단계 모두에 대해 같은 타입으로 쓸 수 있다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li><code>history=[]</code>를 굳이 따로 처리하지 않고, “형식상은 항상 존재하는 값(더미)”이 있다고 생각하면 구현 분기와 수식 분기가 같은 방향으로 맞춰진다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$m_k=0$이면 $h_k=\ast$ 하나뿐이다. 즉 ‘버퍼를 인자로 받지만 실제로는 쓰지 않는’ 1-step solver가 된다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>코드 관점에서는 <code>deque</code>/리스트로 관리하는 ‘이전 값들의 묶음’이다.</li><li>이 버퍼가 있어야 “이번 step의 기울기뿐 아니라 지난 step의 기울기도 섞어서” 같은 문장이 가능해진다.</li><li>warmup 구간에서는 $m_k$가 0→1→…로 증가하므로, ‘처음 몇 step은 같은 이름의 sampler라도 실제로는 저차 공식’이 된다. ComfyUI에서 같은 <code>sampler_name</code>이라도 <code>steps</code>가 아주 작으면 성질이 바뀌는 이유 중 하나가 이 버퍼 부족(warmup)이다.</li><li>샘플링을 중간에 끊었다가 이어갈 때(재개/resume), $x_k$만 저장하면 정보가 손실될 수 있다. multistep이라면 $h_k$까지 같이 저장해야 “정확히 같은 경로”를 이어갈 수 있다(확률론적으로는 $\mathcal{F}_k$-적응성 유지).</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>$\mathcal{X}=\mathbb{R}^2$, 2-step이라면 $x_{k-1}=(1.0,0.0)$, $x_k=(0.3,-0.2)$일 때 $h_k=(x_{k-1},x_k)=((1.0,0.0),(0.3,-0.2))\in\mathcal{H}_k$.</li><li>새 값이 $x_{k+1}=(0.1,0.0)$로 계산되면 버퍼 갱신은 $\Psi_k(h_k,x_{k+1})=((0.3,-0.2),(0.1,0.0))$처럼 ‘앞을 버리고 뒤를 붙이는’ 형태가 된다.</li><li>(warmup 수치 예) $\mathcal{X}=\mathbb{R}$, 목표 history 길이 $m=2$라 하자. 초기에는 $m_0=0$이라 $h_0=\ast$이고, $x_0=0.8\to x_1=0.3$가 되면 $m_1=1$로 $h_1=(0.3)$. 다음에 $x_2=-0.1$이면 $m_2=2$가 되어 $h_2=(x_1,x_2)=(0.3,-0.1)$처럼 ‘필요한 만큼 채워진다’.</li><li>(모델출력 history 예) $\mathcal{X}=\mathbb{R}$에서 과거 denoised를 저장한다고 하자. $d_{k-1}=0.20$, $d_k=0.12$이면 $h_k=(0.20,0.12)$이고, 새 값 $d_{k+1}=0.05$를 얻으면 $h_{k+1}=(0.12,0.05)$로 갱신된다.</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>old_denoised</code>, <code>history</code>, <code>buffer</code> 류 상태가 $\mathcal{H}_k$ 역할을 한다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>warmup 구간에서 $m_k$가 변한다는 점을 빼먹으면 초기 step 구현이 틀리기 쉽다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="X.html">$\mathcal{X}$</a><a class="btn" href="Psi_k.html">$\Psi_k$</a><a class="btn" href="Phi_k.html">$\Phi_k$</a></div><div class="topnav"><a class="btn" href="C_G.html">이전: $(\mathcal{C},\mathcal{G})$</a><a class="btn" href="K_set.html">다음: $\mathcal{K}$</a></div></article></div></body></html>