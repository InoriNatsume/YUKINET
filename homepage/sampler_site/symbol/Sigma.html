<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Sigma</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $\Sigma$</h1><p class='muted'><strong>노이즈 스케일 구간 (Noise scale interval)</strong></p><h2>모티베이션 (Motivation)</h2><p>샘플링 과정에서 ‘현재 노이즈의 세기’를 나타내는 스칼라 $\sigma$가 움직이는 값의 범위(구간)이다. 코드에서는 보통 <code>sigmas</code> (예: <code>sigmas=[10,5,2,1,0]</code>)처럼 step별 $\sigma$ 값 배열로 나타난다.</p><ol class='list'><li>ComfyUI <code>KSampler</code>에서 <code>scheduler</code>는 사실상 <code>sigmas</code> 배열 $(\sigma_0,\dots,\sigma_N)$을 만드는 규칙이다. 사용자가 고르는 <code>steps</code>와 <code>scheduler</code>가 바뀌면 “어느 $\sigma$에서 모델을 몇 번 호출하느냐”가 달라지고, 그 차이가 전역 구성, 디테일, 질감(그레인) 차이로 체감된다.</li><li>img2img/inpaint에서 <code>denoise</code>(또는 <code>start_at_step/end_at_step</code> 같은 고급 옵션)는 전체 $\Sigma$ 구간을 다 쓰지 않고 부분 구간만 따라가게 만든다. 큰 $\sigma$ 영역을 덜 거치면 원본을 더 보존하지만, 동시에 전역 구성이 바뀔 여지도 줄어든다. 이 관계를 설명하려면 $\Sigma$라는 ‘적분 구간’ 개념이 필요하다.</li><li>대부분의 sampler update는 결국 $\sigma$-축에서의 수치적분(ODE 또는 SDE의 근사)이다. 따라서 $\Sigma$ 위에서 step을 어디에 배치하느냐는 곧 step-size 설계이며, 같은 <code>steps</code>라도 저노이즈($\sigma\approx 0$) 근방을 촘촘히 배치하면 미세 디테일이, 고노이즈($\sigma$ 큰) 쪽을 촘촘히 배치하면 전역 구성이 상대적으로 잘 잡히는 경향이 생긴다.</li><li>ComfyUI/k-diffusion 계열에서 <code>eta</code>, <code>s_churn</code>, <code>s_tmin/s_tmax</code>, <code>s_noise</code> 같은 하이퍼파라미터는 “특정 $\sigma$ 구간에서만” 잡음을 더 넣거나(=SDE 성분 강화) step을 뒤틀어 탐색을 넓히는 형태로 설계돼 있다. 즉 이 파라미터들을 이해하려면 먼저 $\Sigma$와 구간 선택을 이해해야 한다.</li><li>문헌/코드마다 시간 변수를 $t\in[0,1]$로 쓰기도 하고, $\sigma$를 직접 쓰기도 한다. 둘은 단조 변환으로 연결되지만, 변수를 섞어 쓰면 ‘같은 공식’이 서로 다른 의미가 된다. $\Sigma$를 명시해 두면 “이 sampler는 어떤 축에서 적분하고 있는가”가 깔끔해진다.</li><li>영상 생성에서는 프레임 간 노이즈/세부 질감의 일관성이 특히 중요하다. $\sigma$가 큰 구간에서의 확률적 변동(추가 noise)이 크면 프레임마다 질감이 들쭉날쭉해질 수 있고, 반대로 저노이즈 구간을 너무 성급히 지나가면 디테일이 흔들릴 수 있다. 이 트레이드오프도 결국 $\Sigma$ 위에서의 설계 문제다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Sigma=[\sigma_{\min},\sigma_{\max}]\subset[0,\infty) $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ S:\{0,\dots,N\}\to\Sigma,\qquad S(k)=\sigma_k $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 “$\sigma$가 음수가 아닌 실수 값이며, 그중에서 우리가 실제로 사용할 범위가 $[\sigma_{\min},\sigma_{\max}]$”라는 뜻이다. 즉 $\Sigma$는 ‘축(axis)’의 역할을 한다.</p><p>둘째 문장은 “이산 step 번호 $k$를 실제 $\sigma$ 값으로 바꿔 주는 함수(룩업)”를 정의한다. 이때 solver는 사실상 $\sigma$ 축 위에서 적분/근사를 수행한다.</p><p>많은 구현에서 $\sigma_N=0$까지 내려가지만, 이론/구현에 따라 $\sigma_{\min}&gt;0$으로 두고 마지막에 별도의 디노이즈 단계로 마무리하기도 한다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Sigma=[\sigma_{\min},\sigma_{\max}]\subset[0,\infty) $$</div><h3>해설</h3><ol class='list'><li>$\Sigma$는 $\sigma$가 가질 수 있는 값들의 집합이다. 보통 시작점은 큰 노이즈 $\sigma_{\max}$, 끝점은 작은 노이즈 $\sigma_{\min}$ (또는 0)이다.</li><li>‘구간’으로 잡는 이유는, solver가 결국 이 구간에서 여러 $\sigma$ 값들을 찍어가며 모델을 평가하기 때문이다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>지도에서 x축 범위를 정하는 것과 같다. 그 범위 안에서만 step을 배치한다.</li></ol><h3>수치 예시</h3><ol class='list'><li>예: $\sigma_{\max}=10$, $\sigma_{\min}=0$이면 $\Sigma=[0,10]$.</li><li>예: $\sigma_{\max}=14.6$, $\sigma_{\min}=0.03$이면 $\Sigma=[0.03,14.6]$.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ S:\{0,\dots,N\}\to\Sigma,\qquad S(k)=\sigma_k $$</div><h3>해설</h3><ol class='list'><li>$S$는 step 번호 $k$를 실제 노이즈 값 $\sigma_k$로 보내는 함수다. 코드에서는 <code>sigmas[k]</code> 룩업으로 구현된다.</li><li>보통 $\sigma_{k+1}\le\sigma_k$로 단조감소하게 둔다. 그래야 ‘점점 노이즈를 줄이며 정제한다’는 그림이 일관된다.</li><li>solver의 실질적인 step-size는 $(\sigma_{k+1}-\sigma_k)$ 또는 그에 준하는 표현으로 나타나므로, 스케줄이 곧 step-size 설계다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>같은 $N$이라도 $S$를 어떻게 고르느냐에 따라 “어느 구간을 자세히 보느냐”가 달라진다.</li></ol><h3>수치 예시</h3><ol class='list'><li>$N=4$이고 <code>sigmas=[10,5,2,1,0]</code>면 $\sigma_0=10$, $\sigma_4=0$.</li><li>같은 $N=4$에서 <code>sigmas=[10,4,1,0.2,0]</code>면 작은 $\sigma$ 구간이 더 촘촘하다($1\to0.2\to0$).</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>큰 $\sigma$일수록 상태가 더 ‘흐릿/랜덤’하고, 작은 $\sigma$일수록 더 ‘정제/결정적’이다.</li><li>스케줄은 ‘큰 $\sigma$ 영역을 빨리 지나갈지, 작은 $\sigma$ 근방을 촘촘히 볼지’를 정하는 손잡이다.</li><li>ComfyUI에서 <code>steps=N</code>은 $\Sigma$ 위에 점을 $N+1$개 찍는다는 뜻이고, <code>scheduler</code>는 그 점들이 어디에 놓일지(=스케줄 $S$)를 정한다. img2img/inpaint의 <code>denoise</code>는 이 구간 중 일부만 따라가게 만들어 ‘원본 보존 vs 변화’ 정도를 조절한다.</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>$\Sigma=[0,10]$이고 step 수 $N=4$라면 한 예로 $\sigma$ 배열을 $(10,\,5,\,2,\,1,\,0)$처럼 둘 수 있다.</li><li>같은 $N=4$에서도 $(10,\,4,\,1,\,0.2,\,0)$처럼 ‘작은 $\sigma$ 쪽을 더 촘촘히’ 두는 스케줄도 가능하다.</li><li>(ComfyUI 단순화) <code>sigmas=[10,5,2,1,0]</code>에서 img2img <code>denoise=0.5</code>를 “큰 $\sigma$ 절반은 생략”으로 생각하면, 대략 $\sigma$가 5에서 0으로 내려가는 부분 $(5,2,1,0)$만 사용하게 된다(정확한 시작점은 구현/스케줄 정의에 따라 달라질 수 있다).</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>sigmas</code>, <code>sigma</code>, <code>sigma_hat</code> 같은 인자/변수가 여기에 해당한다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>시간 $t$와 $\sigma$를 같은 변수처럼 다루면 solver 차수 해석이 꼬인다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="S_map.html">$S$</a><a class="btn" href="D_theta.html">$D_\theta$</a></div><div class="topnav"><a class="btn" href="B_X.html">이전: $\mathcal{B}(\mathcal{X})$</a><a class="btn" href="C_G.html">다음: $(\mathcal{C},\mathcal{G})$</a></div></article></div></body></html>