<!doctype html>
<html lang="ko"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Symbol Wiki: Phi_k</title>
<link rel="stylesheet" href="../assets/style.css"/>
<script>
window.MathJax={
  tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},
  options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head><body><div class="wrap"><article class="paper"><div class="topnav"><a class="btn" href="index.html">기호 위키 인덱스</a><a class="btn" href="../index.html#notation">최상위 문서(기호 탭)</a></div><h1>Symbol: $\Phi_k$</h1><p class='muted'><strong>이산시간 전이 사상 (Discrete-time transition map)</strong></p><h2>모티베이션 (Motivation)</h2><p>한 번의 step 업데이트 규칙 자체를 $\Phi_k$로 적는다. 즉, 코드에서 ‘한 반복’에 해당하는 함수(또는 연산자)를 수학 기호로 이름 붙인 것이다.</p><ol class='list'><li>ComfyUI <code>KSampler</code>의 내부를 한 줄로 쓰면 결국 <code>x = step(x, sigma_k, ...)</code>의 반복이다. 이 ‘한 번의 반복’을 수학적으로 $\Phi_k$로 이름 붙이면, UI에서 보이는 다양한 sampler가 사실은 $\Phi_k$의 정의만 다를 뿐이라는 점이 드러난다.</li><li>sampler를 비교할 때 가장 헷갈리는 부분은 “모델을 몇 번 호출하나”, “중간점에서 무엇을 평가하나”, “노이즈를 언제 뽑아 섞나” 같은 구현 디테일이다. $\Phi_k$를 쓰면 이 모든 차이는 ‘$\Phi_k$의 내부’로 모이고, 외부에서는 $x_{k+1}=\Phi_k(\cdot)$ 한 문장으로 통일된다.</li><li>재현성도 $\Phi_k$로 깔끔하게 정리된다. 결정론 sampler는 $\omega_k$가 필요 없고(또는 $\Omega_k$가 한 점 공간), stochastic sampler는 $\omega_k$가 필요하다. ComfyUI에서 <code>seed</code>를 고정했는데도 sampler에 따라 결과가 조금씩 달라지는 이유가 바로 $\omega_k$의 유무/사용 방식 차이다.</li><li>사용자 파라미터가 어디에 들어가는지도 $\Phi_k$로 보면 명확해진다. <code>scheduler</code>는 $\sigma_k$를 제공하고, <code>cfg</code>는 $D_\theta$ 호출/조합 방식을 바꾸며, <code>eta/s_noise</code>는 $\omega_k$가 섞이는 스케일을 바꾼다. 커스터마이징할 때 “무엇을 건드리면 어떤 성질이 바뀌는가”를 설명하는 공용 언어가 된다.</li><li>영상/다단계 solver에서도 아이디어는 같다: 상태를 확장해 $\Phi_k$의 입력을 키우면(예: $h_k$ 포함, 여러 프레임 포함) 여전히 같은 형태의 반복으로 표현된다. 그래서 새로운 sampler를 설계할 때도 $\Phi_k$를 먼저 정하고 나머지를 붙이는 방식이 가장 깔끔하다.</li></ol><h2>엄밀 정의 (Formal Definitions)</h2><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X} $$</div></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \text{non-anticipative: }\Phi_k\ \text{uses only information up to step }k $$</div></div><h2>정의 해설 (Commentary)</h2><h3>해설(요약) (Summary)</h3><p>첫 문장은 ‘step 함수의 타입’을 적는다. 입력은 (현재 상태 $x_k$, 과거 버퍼 $h_k$, 그리고 난수 접두 $\omega_k$)이고 출력은 다음 상태 $x_{k+1}$다.</p><p>여기서 $\Omega_k$는 “이번 step에서 새로 쓰는 난수”를 담는 공간이라고 보면 된다(예: 표준정규 벡터의 공간). 결정론 solver면 $\Omega_k$가 사실상 한 점 공간으로 축약된다.</p><p>둘째 문장의 적응성(비예견성)은 확률 과정에서 아주 중요한 문법이다. 쉽게 말해 “아직 뽑지 않은 미래 난수는 보지 않는다”를 수식으로 적는 장치다.</p><div class='box'><p class='small'><strong>정의 1.</strong></p><div class='formula'>$$ \Phi_k:(\mathcal{X}\times\mathcal{H}_k\times\Omega_k)\to\mathcal{X} $$</div><h3>해설</h3><ol class='list'><li>이 표기는 “입력 3개를 받는 함수”라는 뜻이다. $x_k\in\mathcal{X}$는 현재 상태, $h_k\in\mathcal{H}_k$는 과거값/과거기울기 버퍼, $\omega_k\in\Omega_k$는 이번 step의 난수다.</li><li>출력은 다음 상태 $x_{k+1}\in\mathcal{X}$ 하나다.</li><li>solver가 1-step이면 $\mathcal{H}_k$가 한 점 공간이라 사실상 영향이 없고, deterministic이면 $\Omega_k$도 한 점 공간이라 난수 입력이 사라진다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>코드의 <code>for k in steps: x = step(x, ...)</code>에서 <code>step</code>이 바로 $\Phi_k$다.</li></ol><h3>수치 예시</h3><ol class='list'><li>결정론 1-step 예: $x_{k+1}=x_k+(\sigma_{k+1}-\sigma_k)\,d_k$는 $\omega_k$ 없이도 정의된다.</li><li>확률 1-step 예: $x_{k+1}=m_k(x_k)+\alpha_k\,\xi_k$처럼 난수 $\xi_k$가 들어가면 $\omega_k$가 필요하다.</li></ol></div><div class='box'><p class='small'><strong>정의 2.</strong></p><div class='formula'>$$ \text{non-anticipative: }\Phi_k\ \text{uses only information up to step }k $$</div><h3>해설</h3><ol class='list'><li>비예견성은 “$x_{k+1}$을 계산할 때 미래 잡음 $\xi_{k+1},\xi_{k+2},\dots$를 미리 보지 않는다”는 뜻이다.</li><li>엄밀히는 $x_k$가 $\mathcal{F}_k$-가측이고, $\Phi_k$가 $(x_k,h_k,\omega_k)$만으로 정의된다는 조건으로 표현된다.</li></ol><h3>직관(정의와 연결)</h3><ol class='list'><li>샘플러 루프는 보통 ‘난수 하나 뽑고 바로 쓰고 넘어간다’ 구조다. 그게 바로 비예견성이다.</li></ol><h3>수치 예시</h3><ol class='list'><li>예: $\xi_0=0.5$를 뽑아 $x_1$을 계산하고, 그 다음에야 $\xi_1=-1.2$를 뽑아 $x_2$를 계산한다. $x_1$을 계산할 때 $\xi_1$을 쓰지 않는다.</li></ol></div><h2>직관(요약) (Intuition)</h2><ol class='list'><li>‘이번 step에서 할 일’ 전체를 묶어 부르는 이름이다.</li><li>deterministic sampler면 난수 입력이 없어 $\Phi_k(x_k,h_k)$처럼 쓸 수도 있다.</li><li>ComfyUI에서 <code>sampler_name</code>이 달라진다는 것은 결국 $\Phi_k$의 내부(중간 평가점, 결합 계수, 노이즈 주입 방식)가 달라진다는 뜻이다. 밖에서 보면 항상 $x\leftarrow \Phi_k(\cdot)$ 반복이므로, 커스텀 샘플러도 $\Phi_k$부터 정의하는 게 가장 빠르다.</li><li>코드 구현 관점에선 $\Phi_k$는 함수 하나로 캡슐화할 수 있다: <code>x_next = step(x, sigma_k, sigma_k1, model, cond, rng, history)</code>처럼. 이렇게 쓰면 ComfyUI와 독립적인 “순수 파이썬 샘플러”로도 이식이 쉽다.</li></ol><h2>구체 원소 예시(모음) (Concrete Examples)</h2><ol class='list'><li>일반형: $x_{k+1}=\Phi_k(x_k,h_k,\omega_k)$.</li><li>(숫자 예) 업데이트가 Euler 형태 $x_{k+1}=x_k+(\sigma_{k+1}-\sigma_k)\,d_k$라고 하자. $x_k=1.0$, $\sigma_k=5.0$, $\sigma_{k+1}=2.0$, $d_k=-0.2$이면 $x_{k+1}=1.0+(2.0-5.0)\cdot(-0.2)=1.6$이다.</li><li>(ancestral 수치 예) 추가 노이즈를 $x_{k+1}=x_k+(\sigma_{k+1}-\sigma_k)d_k+\sigma_{\mathrm{up}}\xi_k$로 넣는다고 하자. 위 예에서 $\sigma_{\mathrm{up}}=0.3$, $\xi_k=0.5$면 노이즈 항은 $0.15$이고 $x_{k+1}=1.6+0.15=1.75$가 된다(같은 drift라도 결과가 흔들림).</li><li>(제약 포함 예) 업데이트 후 클립 제약 $\mathcal{K}=[-1,1]$을 적용하면 $x'=\Phi_k(\cdot)$로 나온 값이 1.75여도 $\Pi_\mathcal{K}(x')=1.0$으로 되돌아간다. 즉 $\Phi_k$ 뒤에 투영을 합성하면 “제약 샘플러”가 된다.</li></ol><h2>코드 대응 (Code Mapping)</h2><ol class='list'><li><code>sample_*</code> 루프 내부의 한 반복 업데이트가 $\Phi_k$다.</li></ol><h2>자주 헷갈리는 점 (Pitfalls)</h2><ol class='list'><li>미래 난수를 참조하면(look-ahead) 확률해석에서 적응성이 깨진다.</li></ol><h2>관련 기호 (Related Symbols)</h2><div class='topnav'><a class="btn" href="Psi_k.html">$\Psi_k$</a><a class="btn" href="S_map.html">$S$</a><a class="btn" href="Omega_F_P.html">$(\Omega,\mathcal{F},\mathbb{P})$</a></div><div class="topnav"><a class="btn" href="g_func.html">이전: $g$</a><a class="btn" href="Psi_k.html">다음: $\Psi_k$</a></div></article></div></body></html>